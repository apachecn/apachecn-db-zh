# 9.InnoDB 集群管理

正如您已经发现的，设置 InnoDB Cluster 并不困难，除了学习如何使用 MySQL Shell 和 AdminAPI 中的一些类和方法之外，配置 InnoDB Cluster 的步骤也同样简单。然而，我们从经验中知道，设置和管理在复杂性上并不总是一致的。

事实上，在 InnoDB Cluster 之前，管理和维护 MySQL 复制需要学习一系列特定的任务和技术，以保持一切正常运行。幸运的是，对于 InnoDB 集群来说，情况并非如此。在 InnoDB 集群的发展过程中，管理任务是一个关键的目标领域，其目标是以更低的复杂性更容易使用。正如您将看到的，除了一些罕见的例外情况，AdminAPI 已经达到了这个目标。

在本章中，您将了解管理 InnoDB 集群的常见任务。当您在自己的环境中探索 InnoDB 集群时，可以将本章作为参考。正如您将看到的，我们已经通过第 [5](05.html) 、 [7](07.html) 和 [8](08.html) 章中的沙盒和实时服务器部署示例浏览了一些任务。为了完整起见，本章使用简短的示例总结了这些任务。任务我们还没有更详细地讨论功能示例。

您还将通过研究保护集群的管理任务，了解如何使您的 InnoDB 集群更加安全。

## 概观

管理 InnoDB 集群需要通过 MySQL Shell 使用 AdminAPI。尽管可以直接使用 InnoDB 集群和组复制，但不建议这样做。InnoDB 集群的管理应该始终通过 AdminAPI 进行。

### 警告

始终通过 MySQL Shell 使用 AdminAPI 来管理 InnoDB 集群。不建议直接使用组复制或 InnoDB 集群元数据。

你在第 5 章[中看到了 AdminAPI 的概述。AdminAPI 中有两个类:`dba`类，用于建立集群并使用实例为集群做准备，以及`cluster`类，用于管理集群，从检查状态到解决实例问题。](05.html)

让我们先简要回顾一下这些工具，然后看看常见的任务。然后我们将讨论故障排除任务，这些任务并不经常使用，只是在出现问题时才使用。

## 工具，命令

使用 InnoDB Cluster 的首选工具是 MySQL Shell，这是本书的重点。这是唯一推荐使用集群的工具。但是，应该注意的是，您可以用 Java 或 Python 编写自己的特殊脚本来处理集群。这两种方法都使用 AdminAPI 来处理集群。同样，您不应该使用任何不使用 AdminAPI 的工具或实用程序。如果您是使用组复制的专家，您可能会尝试通过操作组复制参数和选项来使用群集，但不建议这样做。您应该迁移到使用 MySQL Shell。

在本节中，我们将研究使用 InnoDB 集群的常见管理任务。我们将任务分为以下几类:

*   *常规*:状态和相关检查的基本管理任务

*   *实例*:使用实例的任务

因为本章旨在用作参考，所以示例有些简短，仅显示了可用于完成任务的基本命令。但是，对于那些更频繁使用的任务，会显示详细的示例和输出。此外，示例省略了 MySQL Shell 的连接步骤。有关使用 MySQL Shell 连接到服务器的更多信息，请参见第 [4](04.html) 章。

### 一般

此类别中的任务是那些更频繁执行的任务，包括获取集群、检查状态和描述集群配置。

#### 获取集群

当使用 MySQL Shell 管理 InnoDB 集群时，我们必须首先请求一个`cluster`类的实例。回想一下，在本书中你已经多次看到这种情况。为了检索`cluster`实例，我们使用了`dba.get_cluster()`方法。下面显示了一个检索群集的示例。请记住，我们必须先连接到集群中的一个服务器，然后才能检索它。

```sql
\connect root@cluster-rpi1:3306
cluster = dba.get_cluster()

```

您也可以将集群的名称作为参数传递，但这是用于额外的错误检查(如果服务器不属于指定的集群，则会引发错误)。当您的基础架构中有多个集群时，这很有帮助。

#### 检查集群状态

与上一个任务一样，您之前已经看到了如何检索集群状态报告。回想一下，我们使用的是`cluster.status()`方法。我们必须连接到集群中的一个服务器，检索它，然后使用状态方法:

```sql
\connect root@cluster-rpi1:3306
cluster = dba.get_cluster()
cluster.status()

```

您还可以将检索集群和显示状态的方法链接起来:

```sql
dba.get_cluster().status()

```

如果您想在批处理模式下使用 MySQL Shell 来快速检索状态，这可能会很方便。

#### 描述集群

您还可以获得关于集群的信息，比如集群中机器的主机名以及每个 MySQL 实例使用的端口。我们使用清单 [9-1](#PC4) 中展示的`cluster.describe()`方法。

```sql
MySQL  cluster-rpi2:3306 ssl  Py > cluster = dba.get_cluster('RPI_Cluster')
MySQL  cluster-rpi2:3306 ssl  Py > cluster.describe()
{
    "clusterName": "RPI_Cluster",
    "defaultReplicaSet": {
        "name": "default",
        "topology": [
            {
                "address": "cluster-rpi1:3306",
                "label": "cluster-rpi1:3306",
                "role": "HA"
            },
            {
                "address": "cluster-rpi2:3306",
                "label": "cluster-rpi2:3306",
                "role": "HA"
            },
            {
                "address": "cluster-rpi3:3306",
                "label": "cluster-rpi3:3306",
                "role": "HA"
            },
            {
                "address": "cluster-rpi4:3306",
                "label": "cluster-rpi4:3306",
                "role": "HA"
            },
        ]

    }
}

Listing 9-1Describing the Cluster

```

现在，让我们看看使用实例的任务。

### 例子

此类别中的任务旨在用于单个实例，以将实例加入集群，将实例重新加入集群，检查实例是否适合与 InnoDB 集群一起使用，以及类似的任务。

#### 检查实例是否适合与 InnoDB 集群一起使用

您已经看到了可以用来准备与 InnoDB Cluster 一起使用的实例的两种方法。第一个是`dba.configure_local_instance()`，用于准备在集群中使用的本地机器。第二个是`dba.check_instance_configuration()`，可以用来测试服务器的设置是否正确。与第一种方法不同，检查实例配置方法可以远程运行。以下是每个命令的示例:

```sql
\connect root@localhost:3306
dba.configure_local_instance()
dba.check_instance_configuration('root@cluster-rpi2:43306')

```

#### 检查实例的集群状态

您还可以通过使用`dba.check_instance_state()`方法来检查实例的当前或最后已知状态。此方法将服务器连接信息作为参数，并返回四种状态之一:

*   `OK new`:实例没有执行过任何 GTID 事务，所以不能与集群执行的 GTID 冲突。

*   `OK recoverable`:该实例已经执行了与集群种子实例的已执行 gtid 不冲突的 gtid。

*   `ERROR diverged`:该实例已执行的 gtid 与集群种子实例已执行的 gtid 不同。

*   `ERROR lost_transactions`:实例的已执行 gtid 多于集群种子实例的已执行 gtid。

清单 [9-2](#PC6) 展示了一个运行这个命令的例子。

```sql
MySQL  Py > \connect root@localhost:3306
MySQL  Py > dba.configure_local_instance('localhost:3306')
Please provide the password for 'root@localhost:3306': ****
Configuring local MySQL instance listening at port 3306 for use in an InnoDB cluster...

This instance reports its own address as cluster-rpi3

WARNING: User 'root' can only connect from localhost.
If you need to manage this instance while connected from other hosts, new account(s) with the proper source address specification must be created.

1) Create remotely usable account for 'root' with same grants and password
2) Create a new admin account for InnoDB cluster with minimal required grants
3) Ignore and continue
4) Cancel

Please select an option [1]: 1
Please provide a source address filter for the account (e.g: 192.168.% or % etc) or leave empty and press Enter to cancel.
Account Host: %

Some configuration options need to be fixed:
+--------------------------+---------------+----------+-------------------+
| Variable                 | Current Value | Required | Note              |                                              Value
+--------------------------+---------------+----------------+-------------+
| binlog_checksum          | CRC32         | NONE     | Update the server variable          |
| enforce_gtid_consistency | OFF           | ON       | Update read-only variable and restart the server |
| gtid_mode                | OFF           | ON       | Update read-only variable and restart the server |
+--------------------------+---------------+----------+-------------------+

Do you want to perform the required configuration changes? [y/n]: y
Do you want to restart the instance after configuring it? [y/n]: y

Cluster admin user 'root'@'%' created.
Configuring instance...
The instance 'localhost:3306' was configured for cluster usage.
Restarting MySQL...

MySQL server at localhost:3306 was restarted.

Listing 9-2Configuring the Local Instance

```

#### 将实例加入集群

在本书中，您已经多次看到了如何将实例加入集群。回想一下，我们使用`cluster.add_instance()`方法，传入连接信息以连接到一个实例，从而加入当前集群。此处显示了将实例加入集群的命令示例；我们必须连接到群集中的服务器才能使用此方法:

```sql
\connect root@cluster-rpi1:3306
cluster = dba.get_cluster()
cluster.add_instance('root@cluster-rpi3:3306')

```

#### 将实例重新加入集群

如果服务器与集群断开连接，我们可以使用`cluster.rejoin_instance()`方法将其重新加入集群。这将连接信息作为参数，并尝试将实例重新连接到群集。你在第 8 章中已经看到了这种方法。下面显示了一个将实例重新加入集群的示例。在操作之后检查集群的状态总是一个好主意。

```sql
\connect root@cluster-rpi1:3306
\connect root@cluster-rpi1:3306
cluster = dba.get_cluster()
cluster.rejoin_instance('root@cluster-rpi4:3306')
cluster.status()

```

#### 从集群中删除一个实例

如果您需要在物理机器或服务器上运行的 MySQL 实例上执行维护，您应该首先将它从集群中删除。我们可以用`cluster.remove_instance(`方法做到这一点:

```sql
\connect root@cluster-rpi1:3306
cluster = dba.get_cluster()
cluster.remove_instance('root@cluster-rpi2:3306')
cluster.status()

```

在操作之后检查集群的状态总是一个好主意。如果 InnoDB 集群元数据完好无损，您可以使用`cluster.rejoin_instance()`方法将服务器添加回集群。如果您必须删除数据或重建服务器，您可能需要使用`cluster.add_instance()`方法。

#### 创建实例的白名单

假设我们想要指定一个允许与集群一起使用的服务器列表(一个称为*白名单* <sup>[1](#Fn1)</sup> 的许可列表)，该列表限制只有列表中的机器才能连接到集群。我们可以通过向`create_cluster()`、`add_instance()`或`rejoin_instance()`方法传递一个特殊的参数来显式地创建白名单。例如，下面显示了如何创建一个群集来限制与特定子网(192.168.42.X)上的服务器的连接:

```sql
\connect root@cluster-rpi1:3306
cluster = dba.create_cluster('RPI_Cluster', {ipWhitelist: '192.168.42.0/24"})

```

#### 自定义集群元数据

您可能还记得本书和本章中的各种例子，除了命名集群之外，我们通常不会向集群元数据添加任何定制。这是因为为组名、本地地址和种子实例等选项设置了默认值。然而，我们可以通过在设置和配置方法中覆盖它们来指定这些属性的值，包括`dba.create_cluster()`和`cluster.add_instance()`。

##### 设置组名

要设置复制组的名称，请使用`dba.create_cluster()`方法的`groupName`选项。但是，您必须使用有效的 UUID。下面是一个例子:

```sql
dba.create_cluster('RPI_Cluster', {'groupName':'0cc3ebad-6759-11e8-966f-c49ded13bebf'})

```

您可以通过发出以下 SQL 语句来查看系统变量`group_replication_group_name`中的值:

```sql
\sql;
SHOW VARIABLES LIKE 'group_replication_group_name';

```

##### 设置本地地址

*本地地址*是一个实例为来自其他实例的连接提供的地址。当调用`dba.create_cluster()`和`cluster.add_instance()`方法时，可以通过使用`localAddress`选项来设置本地地址。这将在实例上设置系统变量`group_replication_local_address`。

您必须使用字符串格式`host:port`提供一个值。请注意，该地址必须是群集中所有实例都可以访问的地址(由 DNS 或 hosts 文件条目支持)。此外，Oracle 在《在线参考手册》中指出，该值只能用于内部的实例对实例的通信，而不能用于外部访问集群。以下是如何使用该选项的示例:

```sql
dba.create_cluster('RPI_Cluster', {'localAddress':'192.168.42.241:3306'})

```

您可以通过发出以下 SQL 语句来查看系统变量`group_replication_local_address`中的值:

```sql
\sql;
SHOW VARIABLES LIKE 'group_replication_local_address';

```

##### 设置组种子

*组种子*是当一个实例加入集群时用来连接的那些实例的列表。这允许实例获取正确的元数据以用于集群。当调用`dba.create_cluster()`和`cluster.add_instance()`方法时，可以通过使用`groupSeeds`选项来设置组种子。

使用格式`host1:port1,host2:port2, <etc>`将地址指定为逗号分隔的列表(字符串)。以下是如何使用该选项的示例:

```sql
dba.create_cluster('RPI_Cluster', {'groupSeeds':'192.168.42.241:3306,192.168.42.242:3306'})

```

您可以通过发出以下 SQL 语句来查看系统变量`group_replication_group_seeds`中的值:

```sql
\sql;
SHOW VARIABLES LIKE ' group_replication_group_seeds ';

```

现在，我们来看看故障排除任务。

## InnoDB 集群故障排除

如果您正在努力组建集群并添加实例，那么您的机器或这些机器上的 MySQL 可能会发生一些奇怪的事情。例如，假设您无法添加一个实例，并且已经通过`dba.check_instance_configuration()`方法检查了该实例是否有效，但是集群仍然不接受该实例。在这种情况下，群集可能已经消失(元数据错误、损坏或丢失)。

故障排除类别中的任务是在出现问题或失败时您可能会遇到或需要的任务。这些不是你通常会执行的任务——相反，我们希望永远不需要这些任务！事实上，有些可能被认为是危险的，所以要谨慎使用。

### 从仲裁丢失中恢复

在不寻常的情况下，一个实例可能会失去其法定人数(在失败的情况下，参与投票方案以确定主要成员的能力)。我们可以使用`cluster.force_quorum_using_partition_of()`方法来重新建立法定人数。当实例的状态被设置为`NO_QUORUM`时，您就会知道这已经发生了。下面显示了 AdminAPI 的命令和输出示例:

```sql
cluster.force_quorum_using_partition_of ("localhost:3310")

  Restoring replicaset 'default' from loss of quorum, by using the partition composed of [localhost:3310]

  Please provide the password for 'root@localhost:3310': ******
  Restoring the InnoDB cluster ...

  The InnoDB cluster was successfully restored using the partition from the instance 'root@localhost:3310'.

```

### 警告

使用这种方法要非常小心。可以遇到裂脑的情况。为了避免这种情况，请确保副本集的所有其他成员都被删除或重新加入到被还原的组中。

### 从完全丢失中重新启动

如果您需要在完全中断或丢失后重新启动集群，比如集群中的所有服务器都已关闭(或类似事件)，您可以使用`dba.reboot_cluster_from_complete_outage()`方法。只需确保所有集群服务器都在线，并且 MySQL 在所有节点上都已启动和运行。该任务可用于有意或出于必要而关闭的试验性或开发性集群。清单 [9-3](#PC18) 展示了一个从完全丢失状态重启集群的例子。

```sql
MySQL  Py > \connect root@cluster-rpi1:3306
Creating a session to 'root@cluster-rpi1:3306'
Enter password: ****
Fetching schema names for autocompletion... Press ^C to stop.
Your MySQL connection id is 15
Server version: 8.0.11 MySQL Community Server (GPL)
No default schema selected; type \use <schema> to set one.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster = dba.reboot_cluster_from_complete_outage('RPI_Cluster')
Reconfiguring the cluster 'RPI_Cluster' from complete outage...

The instance 'cluster-rpi2:3306' was part of the cluster configuration.
Would you like to rejoin it to the cluster? [y/N]: y

The instance 'cluster-rpi4:3306' was part of the cluster configuration.
Would you like to rejoin it to the cluster? [y/N]: y

The instance 'cluster-rpi3:3306' was part of the cluster configuration.
Would you like to rejoin it to the cluster? [y/N]: y

The cluster was successfully rebooted.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.status()
{
    "clusterName": "RPI_Cluster",
    "defaultReplicaSet": {
        "name": "default",
        "primary": "cluster-rpi1:3306",
        "ssl": "REQUIRED",
        "status": "OK",
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.",
        "topology": {
            "cluster-rpi1:3306": {
                "address": "cluster-rpi1:3306",
                "mode": "R/W",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi2:3306": {
                "address": "cluster-rpi2:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            }, 

            "cluster-rpi3:3306": {
                "address": "cluster-rpi3:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi4:3306": {
                "address": "cluster-rpi4:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            }
        }

    },
    "groupInformationSourceMember": "mysql://root@cluster-rpi1:3306"
}

Listing 9-3Rebooting the Cluster from Complete Loss

```

### 注意

您必须指定群集名称才能使用此方法。否则，您将得到一个错误。

### 重新扫描集群元数据

如果您(或某人)在不使用 AdminAPI 的情况下对集群进行了更改(比如手动从组复制中添加或删除一台机器)，您可以使用`cluster.rescan()`方法修复 InnoDB 集群元数据。

此方法将尝试修复元数据，并尝试将实例添加到群集。系统将提示您批准找到的每台服务器。如果不允许服务器加入集群或遇到错误，将会报告该服务器，以便您可以在以后尝试添加实例。以下是运行此命令的示例:

```sql
 MySQL  cluster-rpi1:3306 ssl  Py > cluster.rescan()
Rescanning the cluster...

Result of the rescanning operation:
{
    "defaultReplicaSet": {
        "name": "default",
        "newlyDiscoveredInstances": [],
        "unavailableInstances": []
    }
}

```

在这里，我们看不到任何新的或不可用的实例。如果有的话，您会看到它们如下:

```sql
 MySQL  cluster-rpi1:3306 ssl  Py > cluster.rescan()
Rescanning the cluster...

Result of the rescanning operation:
{
    "defaultReplicaSet": {
        "name": "default",
        "newlyDiscoveredInstances": [],
        "unavailableInstances": [
            {
                "host": "cluster-rpi4:3306",
                "label": "cluster-rpi4:3306",
                "member_id": "1fec2731-53d2-11e8-914c-b827ebcb9200"
            }
        ]
    }
}

```

请注意，实例`cluster-rpi4:3306`不再是高可用性设置的一部分。它或者脱机，或者已经离开高可用性组。您可以尝试使用`cluster.rejoin_instance('cluster-rpi4:3306')`命令再次将它添加到集群中，或者从集群配置中删除它。

```sql
Would you like to remove it from the cluster metadata? [Y/n]: n

```

对于这个问题，我们通常不希望在正常情况下删除实例，例如，当您需要将实例脱机进行修复时。所以要回复`N`。另一方面，如果应该删除实例，可以通过回答问题`Y`来实现。

以下是使用`cluster.rejoin_instance()`方法将实例重新加入集群的示例:

```sql
 MySQL  cluster-rpi1:3306 ssl  Py > cluster.rejoin_instance('root@cluster-rpi4:3306')
Rejoining the instance to the InnoDB cluster. Depending on the original
problem that made the instance unavailable, the rejoin operation might not be successful and further manual steps will be needed to fix the underlying problem.

Please monitor the output of the rejoin operation and take necessary action if the instance cannot rejoin.

Please provide the password for 'root@cluster-rpi4:3306': ****
Rejoining instance to the cluster ...

The instance 'cluster-rpi4:3306' was successfully rejoined on the cluster.

```

现在，如果我们重新扫描群集，我们应该会看到不再有任何实例不可用或对群集来说是新的，如下所示:

```sql
 MySQL  cluster-rpi1:3306 ssl  Py > cluster.rescan()
Rescanning the cluster...

Result of the rescanning operation:
{
    "defaultReplicaSet": {
        "name": "default",
        "newlyDiscoveredInstances": [],
        "unavailableInstances": []
    }

}

```

### 集群拆卸

在极少数情况下，您需要从集群中完全删除所有实例并删除集群，您可以使用`cluster.dissolve()`方法。如果您将`force`选项设置为`True`，该方法将删除所有实例并解散集群。与类似的方法一样，这是一种作为最后手段或用于实验或开发的方法。下面是使用方法的一个示例:

```sql
 MySQL  cluster-rpi1:3306 ssl  Py > cluster.dissolve({'force':True})
The cluster was successfully dissolved.
Replication was disabled but user data was left intact.

You can now rebuild your cluster.

```

如果您执行此任务是为了尝试修复错误或重建群集，则可以这样做，因为所有元数据和设置都已从实例中删除。清单 [9-4](#PC25) 显示了如何重建第 [7](07.html) 章中的示例集群。

```sql
 MySQL  cluster-rpi1:3306 ssl  Py > dba.create_cluster('RPI_Cluster')
A new InnoDB cluster will be created on instance 'root@cluster-rpi1:3306'.

The MySQL instance at 'cluster-rpi1:3306' currently has the super_read_only
system variable set to protect it from inadvertent updates from applications. You must first unset it to be able to perform any changes to this instance.
For more information see: https://dev.mysql.com/doc/refman/en/server-system-variables.html#sysvar_super_read_only.

Note: there are open sessions to 'cluster-rpi1:3306'.
You may want to kill these sessions to prevent them from performing unexpected updates:

1 open session(s) of 'root@192.168.42.240'.

Do you want to disable super_read_only and continue? [y/N]: y

Validating instance at cluster-rpi1:3306...

This instance reports its own address as cluster-rpi1

Instance configuration is suitable.
Creating InnoDB cluster 'RPI_Cluster' on 'root@cluster-rpi1:3306'...
Adding Seed Instance...

Cluster successfully created. Use Cluster.add_instance() to add MySQL instances. At least 3 instances are needed for the cluster to be able to withstand up to one server failure.

<Cluster:RPI_Cluster>

 MySQL  cluster-rpi1:3306 ssl  Py > cluster = dba.get_cluster()
 MySQL  cluster-rpi1:3306 ssl  Py > cluster.add_instance('root@cluster-rpi2:3306')
A new instance will be added to the InnoDB cluster. Depending on the amount of data on the cluster this might take from a few seconds to several hours.

Please provide the password for 'root@cluster-rpi2:3306': ****
Adding instance to the cluster ...

Validating instance at cluster-rpi2:3306...

This instance reports its own address as cluster-rpi2

Instance configuration is suitable.

The instance 'root@cluster-rpi2:3306' was successfully added to the cluster.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.add_instance('root@cluster-rpi3:3306')
A new instance will be added to the InnoDB cluster. Depending on the amount of data on the cluster this might take from a few seconds to several hours.

Please provide the password for 'root@cluster-rpi3:3306': ****
Adding instance to the cluster ...

Validating instance at cluster-rpi3:3306...

This instance reports its own address as cluster-rpi3

Instance configuration is suitable.
The instance 'root@cluster-rpi3:3306' was successfully added to the cluster.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.add_instance('root@cluster-rpi4:3306')
A new instance will be added to the InnoDB cluster. Depending on the amount of data on the cluster this might take from a few seconds to several hours.

Please provide the password for 'root@cluster-rpi4:3306': ****
Adding instance to the cluster ...

Validating instance at cluster-rpi4:3306...

This instance reports its own address as cluster-rpi4

Instance configuration is suitable.

The instance 'root@cluster-rpi4:3306' was successfully added to the cluster.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.status()
{
    "clusterName": "RPI_Cluster",
    "defaultReplicaSet": {
        "name": "default",
        "primary": "cluster-rpi1:3306",
        "ssl": "REQUIRED",
        "status": "OK",
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.",
        "topology": {
            "cluster-rpi1:3306": {
                "address": "cluster-rpi1:3306",
                "mode": "R/W",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            }, 

            "cluster-rpi2:3306": {
                "address": "cluster-rpi2:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi3:3306": {
                "address": "cluster-rpi3:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi4:3306": {
                "address": "cluster-rpi4:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            }
        }

    },
    "groupInformationSourceMember": "mysql://root@cluster-rpi1:3306"
}

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.describe()
{
    "clusterName": "RPI_Cluster",
    "defaultReplicaSet": {
        "name": "default",
        "topology": [
            {
                "address": "cluster-rpi1:3306",
                "label": "cluster-rpi1:3306",
                "role": "HA"
            },
            {
                "address": "cluster-rpi2:3306",
                "label": "cluster-rpi2:3306",
                "role": "HA"
            },
            {
                "address": "cluster-rpi3:3306",
                "label": "cluster-rpi3:3306",
                "role": "HA"
            },

            {
                "address": "cluster-rpi4:3306",
                "label": "cluster-rpi4:3306",
                "role": "HA"
            }
        ]
    }
}

Listing 9-4Reestablishing the Cluster after Dissolving

```

### 从元数据错误中恢复

如果您的服务器关机，比如说，您在一天结束时将它们全部关闭，那么当第二天重新开始工作时，您可能会遇到以下错误(或类似的错误)。这是因为 InnoDB 集群(以及任何高可用性系统)不是为关闭和重启而设计的。您可以关闭一些服务器进行维护，但是您应该始终保持至少三台服务器运行。尽管 InnoDB 集群将继续运行，但在至少三台服务器添加到集群之前，日志中会出现警告和潜在错误。因此，如果您只有三个实例，并且必须让其中一个脱机进行维护，那么您可以。但是，您应该考虑在维护任务期间向集群添加另一个实例，以确保您拥有最少数量的实例。

```sql
 MySQL  localhost:33060+ ssl  Py > cluster = dba.get_cluster('RPI_Cluster')
Traceback (most recent call last):
  File "<string>", line 1, in <module>
SystemError: RuntimeError: Dba.get_cluster: This function is not available through a session to a standalone instance (metadata exists, but GR is not active)

```

下面演示了如何从完全中断中恢复集群。具体来说，所有服务器都已重新启动(关闭电源并重新启动)，您需要从最后一个已知良好的位置重新启动集群。我们将使用`dba.reboot_cluster_from_complete_outage()`方法重启集群。首先，登录到其中一个服务器，运行如下命令:

```sql
 MySQL  localhost:33060+ ssl  Py > cluster = dba.reboot_cluster_from_complete_outage('RPI_Cluster')
Reconfiguring the cluster 'RPI_Cluster' from complete outage...

The instance '192.168.42.244:3306' was part of the cluster configuration.
Would you like to rejoin it to the cluster? [y/N]: y

The instance '192.168.42.243:3306' was part of the cluster configuration.
Would you like to rejoin it to the cluster? [y/N]: y

The instance '192.168.42.242:3306' was part of the cluster configuration.
Would you like to rejoin it to the cluster? [y/N]: y

The cluster was successfully rebooted.

```

如果成功，您将看到消息，指示集群已重新启动。

### 最后手段

如果在尝试恢复集群后，您仍然有问题，并希望从头开始，您可以通过在每台服务器上发出以下命令来实现。这是一个相当激进的步骤，将删除所有元数据并重新启动组复制。但是，您应该将此作为最后的手段，因为它会中断停机事件期间发生的任何事务的正常流程(不太可能，但有可能)。

```sql
dba.drop_metadata_schema()
RESET SLAVE
RESET MASTER

```

第一个命令删除 InnoDB 集群元数据，有效地将服务器从集群中删除。接下来的两个 SQL 命令重置服务器上的复制。回想一下，我们可以通过连接到机器的 MySQL Shell 运行这些命令，但是我们必须对第一个命令使用 Python 模式(`\py`)，对最后两个命令使用 SQL 模式(`\sql`)。

### 警告

这是一项非常危险的任务，建议仅作为最后手段使用。

在所有服务器上输入这些命令后，您可以通过创建集群并添加实例来重新开始。同样，这是最后一招，不推荐用于任何生产系统。

现在，让我们看看管理 MySQL InnoDB 集群的一些最佳实践。

## 最佳实践

现在，您已经看到了修复集群可能需要的常见维护任务以及一些故障排除任务的列表，让我们讨论几个管理 InnoDB 集群的关键最佳实践。本节中列出的实践既不完整，也不是您应该为 InnoDB 集群考虑的唯一实践。相反，这里列出的实践旨在提醒您应该采用的关键实践。此外，这些实践假设您也在为任何高可用性系统采用典型的最佳实践。

我们从一些对某些人来说似乎平凡但有价值的事情开始，包括对 InnoDB 集群或高可用性解决方案的新手。除了您在组织中开发的最佳实践之外，以下部分还包含您应该考虑的最佳实践。

### 没有关机和重启

高可用性系统不是为定期关闭和重启而设计的。事实上，AdminAPI 中没有“关闭”命令。此语句指的是整个集群，而不是单个实例；您可能需要让实例脱机进行维护或修复，但是集群不应该关闭(唯一的例外是实验或开发试验)。您应该规划您的 InnoDB 集群安装，这样您就不必经常关闭或重启它。

### 在进行更改之前，请备份您的数据

对于拥有值为 <sup>[2](#Fn2)</sup> 的数据的任何系统的任何管理员来说，一个主要的工具是在进行任何更改之前保存数据的能力。这里选择的工具是备份和恢复实用程序。幸运的是，MySQL 在社区版中附带了两个这样的工具:`mysqlpump`和`mysqldump`。这些是逻辑备份工具，允许您使用 SQL 语句创建文件，以便从一个或多个数据库中恢复数据。`mysqlpump`实用程序是`mysqldump`的替代品，工作得更好，特别是对于大型数据库，因为`mysqlpump`可以执行并行转储。但是，这两种方法都可以在本演示中使用。

如前所述，这些是逐行制作数据副本的逻辑备份实用程序，而不是制作数据二进制副本的二进制备份。因此，逻辑备份往往比二进制备份更慢，占用的空间也更多。二进制备份通常还允许服务器在短时间内锁定数据，允许在服务器在线并接受更改时进行备份(有时称为*热备份*)。逻辑备份通常需要在备份期间锁定数据库。对于本演示，我们没有大型数据集，也不担心在线备份操作，因此可以毫无问题地使用逻辑备份。

### MySQL 的企业级备份

如果您计划在您的企业中使用 MySQL，尤其是如果您计划部署 InnoDB 集群，您应该考虑企业版。虽然它是 Oracle 的付费产品，但它包含了许多企业级工具，包括 MySQL 企业备份(MEB)。

MEB 是一个完整的二进制备份工具，允许提供 MySQL 服务器的备份和恢复所需的所有备份方式。MEB 可以执行完整备份、增量备份、加密备份、压缩备份等等。如果您有兴趣了解更多关于 MEB 的信息，请参阅在线 MySQL 企业备份参考手册 [`https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/`](https://dev.mysql.com/doc/mysql-enterprise-backup/8.0/en/) 。

在本节中，您将了解如何在执行任何维护操作之前对我们的数据进行逻辑备份。这对于允许您从禁用数据或以某种方式危及数据(或数据本身)访问的更改中恢复是必不可少的。一个好的系统管理员应该总是在进行任何维护之前进行备份。在确认更改是正确的之后，如果空间有问题，您可以随时删除备份文件。 <sup>[3](#Fn3)</sup>

如果集群处于活动状态，让我们首先备份我们创建的数据，以确保不会丢失。因为我们只有少量的数据，所以我们将使用名为`mysqlpump`的简单的逻辑备份工具。让我们从应用服务器开始工作。

下面显示了一个命令，您可以使用该命令对示例数据库执行逻辑备份，并将其存储在应用服务器上。我们必须提供用户连接信息、主机和端口。我们还提供了一个选项来生成位于文件顶部的`DROP DATABASE`和`TABLE`命令，这有助于通过首先删除数据来恢复数据。我们还添加了一个选项，将`GTID_PURGED`变量设置为`OFF`，这样我们就不会捕获 GTID 信息。回想一下，InnoDB 集群使用组复制，但是我们使用 InnoDB 集群和 AdminAPI 来管理集群，所以我们不需要 GTID 信息。我们将把这个文件命名为`backup_pre_changes.sql`。它被命名为`.sql`文件，因为`mysqlpump`创建 SQL 语句来保存模式和数据。

```sql
$ mysqlpump -uroot -p -h localhost --port=3306 --add-drop-database --add-drop-table --set-gtid-purged=OFF shopping > backup_pre_changes.sql

```

当您执行这个命令时，看起来什么也不会发生，因为我们将所有输出重定向到了该文件。这是因为该实用程序将 SQL 命令打印到标准输出。如果您感到好奇，请打开该文件并查看 SQL 命令。清单 [9-5](#PC30) 是文件应该包含的内容的示例摘录。

```sql
-- Dump created by MySQL pump utility, version: 8.0.11, Linux (armv7l)
-- Dump start time: Fri Jun  1 15:23:00 2018
-- Server version: 8.0.11

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE;
SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
SET @@SESSION.SQL_LOG_BIN= 0;
SET @OLD_TIME_ZONE=@@TIME_ZONE;
SET TIME_ZONE='+00:00';
SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT;
SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS;
SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION;
SET NAMES utf8mb4;
SET @@GLOBAL.GTID_PURGED=/*!80000 '+'*/ '16cce4a6-53d1-11e8-badc-b827eb2bc4f3:1-2,
2d550a88-5453-11e8-9517-b827eb2bc4f3:1-27,
4127c169-520f-11e8-a834-b827ebcb9200:1-170,
4b2d0de2-5454-11e8-9517-b827eb2bc4f3:1-3,
de5cbffd-5455-11e8-85a7-b827eb2bc4f3:1-119:1000102,
f1cdcfd9-62a2-11e8-9e50-b827eb2bc4f3:1-37,
fc2bf2b7-53ca-11e8-a131-b827eb2bc4f3:1-2';
DROP DATABASE IF EXISTS `shopping`;
CREATE DATABASE /*!32312 IF NOT EXISTS*/ `shopping` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */;
DROP TABLE IF EXISTS `shopping`.`list`;
CREATE TABLE `shopping`.`list` (
`rowid` int(11) NOT NULL AUTO_INCREMENT,
`description` char(64) DEFAULT NULL,
`note` char(64) DEFAULT NULL,
`purchased` int(11) DEFAULT '0',
PRIMARY KEY (`rowid`)

) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
;
INSERT INTO `shopping`.`list` VALUES (1,"Milk","2%",1),(2,"Bread",”,0),(3,"Eggs","Free range",0),(4,"Cheese","Cheddar",0),(5,"Bagels",”,0);
Dump progress: 1/1 tables, 0/5 rows
mysqlpump: [WARNING] (3719) 'utf8' is currently an alias for the character set UTF8MB3, which will be replaced by UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
mysqlpump: [WARNING] (3719) 'utf8' is currently an alias for the character set UTF8MB3, which will be replaced by UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.
SET TIME_ZONE=@OLD_TIME_ZONE;
SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT;
SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS;
SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
SET SQL_MODE=@OLD_SQL_MODE;
-- Dump end time: Fri Jun  1 15:23:11 2018
Dump completed in 10798

Listing 9-5Example Logical Backup (mysqlpump)

```

如果您需要恢复数据，您可以使用 MySQL Shell 通过在 SQL 模式下使用`\source`命令来读取文件，如清单 [9-6](#PC31) 所示。但是，除非您不小心删除了数据，否则您不需要这样做。此外，为了恢复 InnoDB 集群中的数据，您应该在读/写服务器连接上运行该命令(6446)。

```sql
pi@cluster-rpi1:~ $ mysqlsh root@cluster-rpi1:3306 --sql
Creating a session to 'root@cluster-rpi1:3306'
Enter password: ****
Fetching schema names for autocompletion... Press ^C to stop.
Your MySQL connection id is 93
Server version: 8.0.11 MySQL Community Server (GPL)
No default schema selected; type \use <schema> to set one.
MySQL Shell 8.0.11

Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type '\help' or '\?' for help; '\quit' to exit.

 MySQL  cluster-rpi1:3306 ssl  SQL > \source shopping_logical_backup.sql
Query OK, 0 rows affected (0.0022 sec)
Query OK, 0 rows affected (0.0018 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0016 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0019 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0019 sec)
Query OK, 1 row affected (0.2923 sec)
Query OK, 1 row affected (0.0121 sec)
Query OK, 0 rows affected, 1 warning (0.0083 sec)
Note (code 1051): Unknown table 'shopping.list'
Query OK, 0 rows affected (0.1067 sec)
Query OK, 5 rows affected (0.0187 sec)

Records: 5  Duplicates: 0  Warnings: 0
Query OK, 0 rows affected (0.0013 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0018 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0018 sec)
Query OK, 0 rows affected (0.0017 sec)
Query OK, 0 rows affected (0.0015 sec)

Listing 9-6Restoring a Logical Backup (mysqlsh)

```

### 小费

在对集群进行重大更改之前，请务必备份您的数据。

### 思考群体，而不是独立的服务器

学习如何部署和管理 InnoDB 集群的最大障碍之一是将集群视为一组相似的服务器，而不是一组单独的服务器。对于那些来自传统 MySQL 主/从复制的人来说，这是特别重要的一课。过去，人们通常认为拓扑中的服务器是必须单独使用的个体。这是因为我们有通过中继日志处理来自单个主服务器的更改的机器，而这些服务器(从服务器)从不互相通信。

但是，InnoDB Cluster(由于其组复制根)将集群中的机器视为一个组，其中一台(或多台)充当读/写服务器。事实上，管理哪台机器扮演哪种角色是自动的，所以我们不需要知道哪台服务器扮演哪种角色。MySQL 路由器的加入为我们处理了集群中发生的变化。

在使用 InnoDB 集群时，我们必须将集群视为基础设施的高可用性组件，而不是一组松散耦合的服务器。这将允许您将 InnoDB Cluster 本身视为一个数据存储，这正是它应该成为的。

虽然硬件维护仍然是基于一台机器进行的，但是可以从集群中的任何机器或者不在集群中的另一台机器上使用 InnoDB 集群。这使得事情比旧形式的 MySQL 复制容易得多，使开发人员能够专注于应用程序，而不是这种高可用性数据存储的细节。

### 保护 InnoDB 集群

最后一个最佳实践应该是任何人首先想到的—安全性！鉴于来自组织内外的威胁不断增加，提高安全性必须成为任何项目的首要目标。InnoDB 集群也不例外。

开发人员不仅应该考虑保护他们的应用程序，还应该考虑保护幕后的数据和服务。事实上，所有使用互联网的解决方案都必须开发更好的安全实践。高可用性解决方案的独特方面使得计划和实施严格的安全实践变得特别困难，因为存在多个漏洞点。更具体地说，每个组件可能有不同类型的漏洞，从对设备的物理访问到对服务的远程攻击。

最近一连串的大规模数据泄露证明了他们的安全性不够。我们已经看到了从直接盗窃到利用从知名企业(如 Target)和政府机构(如美国人事管理办公室)窃取的数据(超过 4000 万个信用卡号可能已被泄露)的一切。有趣的是，违规的源头可以追溯到第三方承包商和服务。显然，没有人是安全的。我们需要一个革命性的步骤，而不是改进行之有效的机制。

可悲的是，在保护我们的解决方案方面，我们能走的路是有限的。任何信息技术(IT)专业人士都会告诉您，应用最好的、严格的密码策略和严密的安全措施会迫使用户危及旨在保护他们及其数据的策略。例如，考虑要求密码为 16 个或更多字符的密码策略，其中至少有四个大写字母、六个数字、三个特殊字符，并且没有英语词典单词；每 60 天过期一次；并且与以前的密码相同的字符不超过七个。在这种情况下，一些用户将被迫写下他们的密码，因为他们记不住字母、大写字母、数字和特殊字符的随机组合。

然而，让密码更难猜测或破解只是一种策略。事实上，关于如何正确保护系统存在各种不同的理念。尽管对所有技术的深入讨论超出了本书的范围，但是考虑如何提高 InnoDB 集群的安全性是很重要的。

那么，我们该怎么办？我们是否实施了良好的实践来确保系统不被轻易破坏，或者我们是否为了易用性而冒降低安全性的风险？底线是，您必须选择最能满足保护数据和服务需求的安全解决方案，而不强迫用户忍受繁重的实践，也不使他们的生活变得困难。

InnoDB Cluster 旨在与 MySQL 中最新的安全改进一起工作，包括新的身份验证插件( [`https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html`](https://dev.mysql.com/doc/refman/8.0/en/caching-sha2-pluggable-authentication.html) )，使其比 MySQL 的任何早期版本都更安全。然而，我们可以做更多的事情来保护我们的数据。幸运的是，MySQL 通过启用 SSL 连接来加密集群和客户端之间的通信(是的，甚至通过路由器)，使这一点变得很容易。

保护 InnoDB 集群有两个主要方面或工具。首先，我们应该使用 SSL 连接。其次，我们可以添加一个服务器白名单，只允许某些服务器访问集群。

#### SSL 连接

默认情况下，在 MySQL 8 的 GA 版本中，MySQL 服务器启用了 SSL 连接。如果您使用的是 MySQL 8.0.11 或更高版本，那么集群中服务器之间的连接已经配置了 SSL。但是，如果您加载了不同的身份验证插件，或者正在使用较旧但兼容的 MySQL 5.7 服务器，您可能需要考虑启用 SSL 连接。

### 小费

MySQL 可以配置为只使用安全连接。在 MySQL 中设置 SSL 的完整教程可以在在线参考手册的“使用加密连接”一节中找到。

通过在任何服务器上发出清单 [9-7](#PC32) 中所示的查询，您可以快速确定您的服务器是否正在使用 SSL。注意,`HAVE_SSL`变量被设置为`YES,`, SSL 选项也相应地被填充，只有最少的一组选项。

```sql
SHOW VARIABLES LIKE '%ssl%';
+---------------------------------------------------+-----------------+
| Variable_name                                     | Value           |
+---------------------------------------------------+-----------------+
| group_replication_recovery_ssl_ca                 |                 |
| group_replication_recovery_ssl_capath             |                 |
| group_replication_recovery_ssl_cert               |                 |
| group_replication_recovery_ssl_cipher             |                 |
| group_replication_recovery_ssl_crl                |                 |
| group_replication_recovery_ssl_crlpath            |                 |
| group_replication_recovery_ssl_key                |                 |
| group_replication_recovery_ssl_verify_server_cert | OFF             |
| group_replication_recovery_use_ssl                | ON              |
| group_replication_ssl_mode                        | REQUIRED        |
| have_openssl                                      | YES             |

| have_ssl                                          | YES             |

| mysqlx_ssl_ca                                     |                 |
| mysqlx_ssl_capath                                 |                 |
| mysqlx_ssl_cert                                   |                 |
| mysqlx_ssl_cipher                                 |                 |
| mysqlx_ssl_crl                                    |                 |
| mysqlx_ssl_crlpath                                |                 |
| mysqlx_ssl_key                                    |                 |
| ssl_ca                                            | ca.pem          |
| ssl_capath                                        |                 |
| ssl_cert                                          | server-cert.pem |
| ssl_cipher                                        |                 |
| ssl_crl                                           |                 |
| ssl_crlpath                                       |                 |
| ssl_fips_mode                                     | OFF             |
| ssl_key                                           | server-key.pem  |
+---------------------------------------------------+-----------------+
27 rows in set (0.0415 sec)

Listing 9-7Displaying the SSL Variables

```

我们告诉 InnoDB Cluster 使用 SSL 的方式是在`dba.create_cluster()`方法期间向集群传递一个选项，就像我们设置其他元数据一样。在这种情况下，我们必须将`memberSslMode`键设置为以下值之一。如您所见，默认情况下在创建时使用 SSL，因此按照本书中的演示创建集群将确保集群配置为 SSL 连接。

*   `AUTO`:(默认)如果服务器实例支持 SSL 加密，则自动启用，如果服务器不支持，则禁用。

*   `REQUIRED`:集群中的种子实例启用了 SSL 加密。如果无法启用，则会引发错误。

*   `DISABLED`:确保对集群中的种子实例禁用 SSL 加密。

类似地，当我们使用`cluster.add_instance()`方法添加实例或使用`cluster.rejoin_instance()`方法允许实例重新加入集群时，实例上的 SSL 加密会根据种子实例(我们创建集群的第一个实例)的设置启用或禁用。但是，您可以对这些方法使用相同的`memberSslMode`选项来控制 SSL 连接，如下所示。正如您所看到的，默认情况下对实例使用 SSL，就像创建集群一样。

*   `AUTO`:(默认)SSL 加密根据种子实例(集群的其他成员)使用的设置和实例本身提供的可用 SSL 支持自动启用或禁用。

*   `REQUIRED`:强制为集群中的实例启用 SSL 加密。

*   `DISABLED`:确保对集群中的实例禁用 SSL 加密。

对于已经配置了组复制的 InnoDB 集群的部署，我们可以在创建集群时使用`adoptFromGR`键告诉 InnoDB 集群采用现有组的 SSL 设置。这样做时，所采用的集群上的 SSL 设置不会改变。

### 注意

`memberSslMode`键不能与`adoptFromGR`键一起使用。

#### 服务器白名单

正如前面“创建实例白名单”一节中提到的，您可以创建一个服务器白名单，限制对某些服务器的访问，这样就没有其他服务器可以连接或加入集群。如果您有一个大型基础架构，并且希望将对集群的访问隔离到一组服务器，以实现划分或类似的组织目标，这是一个很好的选择。

回想一下，我们可以通过向`create_cluster()`、`add_instance()`或`rejoin_instance()`方法传递一个特殊的参数来显式地创建白名单。因此，在配置服务器之前，必须考虑使用白名单。但是，如果您想为一个现有的集群建立一个白名单，您可能需要删除该实例，然后将其添加回集群，传递元数据以将其添加到白名单中。

### 小费

如果计划使用白名单，应该在创建集群和添加实例时设置白名单选项。

#### 示例:需要 SSL 连接

这些选项最安全的形式是将`memberSslMode`设置为`REQUIRED`。让我们看一个简短的例子来说明如何做到这一点。与此同时，我们还将创建一个服务器白名单，以进一步保护集群。回想一下，我们通过将`ipWhitelist`设置为子网 192.168.42 来实现这一点。否则，我们发出创建集群和添加实例的普通命令，但是我们将以下选项传递给这些方法。在本节中，您将看到使用该选项的演示。

```sql
{'memberSslMode': 'REQUIRED', 'ipWhitelist': '192.168.42.0/24'}

```

这些选项允许我们通过始终要求 SSL 连接和限制对指定子网上的那些服务器的访问来使我们的集群更加安全。如果集群正在运行(并且已经进行了备份)，请继续解散集群，如下所示。执行此操作之前，请务必进行备份，以免意外丢失任何数据。

```sql
MySQL  cluster-rpi1:3306 ssl  Py > cluster.dissolve({'force':True})
The cluster was successfully dissolved.
Replication was disabled but user data was left intact.

```

集群解散后，您可以关闭所有服务器的 MySQL 实例。回想一下，我们可以通过 MySQL Shell 使用`SHUTDOWN` SQL 命令关闭 MySQL，如下所示。记得使用`--sql`选项！在集群中的所有计算机上运行以下命令:

```sql
$ mysqlsh root@cluster-rpi1:3306 --sql -e "SHUTDOWN"

```

接下来，如果没有在所有服务器上配置 SSL，我们应该现在就设置它。再说一遍，如果你用的是 MySQL 8.0.11 或者更高版本，那就已经这样了。如果不确定，可以运行以下命令来确定每台服务器上是否启用了 SSL:

```sql
SHOW VARIABLES LIKE 'have_ssl';

```

好了，现在我们准备好了。我们将这个示例集群命名为`RPI_Cluster_SSL`,以表明它需要 SSL 连接。我们发出以下命令来创建集群并添加所有实例:

```sql
cluster = dba.create_cluster('RPI_Cluster_SSL', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
cluster.add_instance('root@cluster-rpi2:3306', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
cluster.add_instance('root@cluster-rpi3:3306', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
cluster.add_instance('root@cluster-rpi4:3306', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})

```

请注意，白名单值是 192.168.42.0/24，它允许从 192.168.42.1 到 192.168.42.255 的连接。如果想要更多的限制，可以用更宽的口罩。如果你不确定如何计算，你可以使用在线子网计算器，比如在 [`www.subnet-calculator.com`](http://www.subnet-calculator.com) 找到的那种。

让我们看一个演示。清单 [9-8](#PC38) 展示了一个设置集群的例子，这个集群需要 SSL，并且已经指定了一个白名单。因为您已经看到了这些命令的运行，所以我们将跳过对这些命令的详细解释，而将注意力集中在清单末尾的状态报告上。

```sql
MySQL  cluster-rpi1:3306 ssl  Py > cluster = dba.create_cluster('RPI_Cluster_SSL', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
A new InnoDB cluster will be created on instance 'root@cluster-rpi1:3306'.

Validating instance at cluster-rpi1:3306...

This instance reports its own address as cluster-rpi1

Instance configuration is suitable.
Creating InnoDB cluster 'RPI_Cluster_SSL' on 'root@cluster-rpi1:3306'...
Adding Seed Instance...

Cluster successfully created. Use Cluster.add_instance() to add MySQL instances.
At least 3 instances are needed for the cluster to be able to withstand up to
one server failure.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.add_instance('root@cluster-rpi2:3306', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
A new instance will be added to the InnoDB cluster. Depending on the amount of
data on the cluster this might take from a few seconds to several hours.

Please provide the password for 'root@cluster-rpi2:3306': ****
Adding instance to the cluster ...

Validating instance at cluster-rpi2:3306...

This instance reports its own address as cluster-rpi2

Instance configuration is suitable.
The instance 'root@cluster-rpi2:3306' was successfully added to the cluster.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.add_instance('root@cluster-rpi3:3306', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
A new instance will be added to the InnoDB cluster. Depending on the amount of
data on the cluster this might take from a few seconds to several hours.

Please provide the password for 'root@cluster-rpi3:3306': ****
Adding instance to the cluster ...

Validating instance at cluster-rpi3:3306...

This instance reports its own address as cluster-rpi3

Instance configuration is suitable.
The instance 'root@cluster-rpi3:3306' was successfully added to the cluster.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.add_instance('root@cluster-rpi4:3306', {'memberSslMode':'REQUIRED', 'ipWhitelist':'192.168.42.0/24'})
A new instance will be added to the InnoDB cluster. Depending on the amount of
data on the cluster this might take from a few seconds to several hours.

Please provide the password for 'root@cluster-rpi4:3306': ****
Adding instance to the cluster ...

Validating instance at cluster-rpi4:3306...

This instance reports its own address as cluster-rpi4

Instance configuration is suitable.
The instance 'root@cluster-rpi4:3306' was successfully added to the cluster.

 MySQL  cluster-rpi1:3306 ssl  Py > cluster.status()
{
    "clusterName": "RPI_Cluster_SSL",
    "defaultReplicaSet": {
        "name": "default",
        "primary": "cluster-rpi1:3306",
        "ssl": "REQUIRED",
        "status": "OK",
        "statusText": "Cluster is ONLINE and can tolerate up to ONE failure.",
        "topology": {
            "cluster-rpi1:3306": {
                "address": "cluster-rpi1:3306",
                "mode": "R/W",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi2:3306": {
                "address": "cluster-rpi2:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi3:3306": {
                "address": "cluster-rpi3:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            },
            "cluster-rpi4:3306": {
                "address": "cluster-rpi4:3306",
                "mode": "R/O",
                "readReplicas": {},
                "role": "HA",
                "status": "ONLINE"
            }
        }
    },
    "groupInformationSourceMember": "mysql://root@cluster-rpi1:3306"
}

Listing 9-8Example Cluster Setup with SSL = Required and Whitelist Defined

```

请注意，在状态报告中，我们看到 SSL 模式是必需的(这是默认的)。我们可以通过查询 SSL 选项来确认这一点:

```sql
MySQL  cluster-rpi1:3306 ssl  mysql_innodb_cluster_metadata  SQL > SHOW VARIABLES LIKE '%ssl%';
+---------------------------------------------------+-----------------+
| Variable_name                                     | Value           |
+---------------------------------------------------+-----------------+
| group_replication_recovery_ssl_ca                 |                 |
| group_replication_recovery_ssl_capath             |                 |
| group_replication_recovery_ssl_cert               |                 |
| group_replication_recovery_ssl_cipher             |                 |
| group_replication_recovery_ssl_crl                |                 |
| group_replication_recovery_ssl_crlpath            |                 |
| group_replication_recovery_ssl_key                |                 |
| group_replication_recovery_ssl_verify_server_cert | OFF             |
| group_replication_recovery_use_ssl                | ON              |
| group_replication_ssl_mode                        | REQUIRED        |
| have_openssl                                      | YES             |
| have_ssl                                          | YES             |
| mysqlx_ssl_ca                                     |                 |
| mysqlx_ssl_capath                                 |                 |
| mysqlx_ssl_cert                                   |                 |
| mysqlx_ssl_cipher                                 |                 |
| mysqlx_ssl_crl                                    |                 |
| mysqlx_ssl_crlpath                                |                 |
| mysqlx_ssl_key                                    |                 |
| ssl_ca                                            | ca.pem          |
| ssl_capath                                        |                 |
| ssl_cert                                          | server-cert.pem |
| ssl_cipher                                        |                 |
| ssl_crl                                           |                 |
| ssl_crlpath                                       |                 |
| ssl_fips_mode                                     | OFF             |
| ssl_key                                           | server-key.pem  |
+---------------------------------------------------+-----------------+
27 rows in set (0.0391 sec)

```

那么，白名单呢？我们可以通过检查组复制的变量来查看白名单，如清单 [9-9](#PC40) 所示。我们可以看到白名单以及组复制的所有其他变量，所有这些都是 InnoDB Cluster 为我们设置的。

```sql
MySQL  cluster-rpi1:3306 ssl  mysql_innodb_cluster_metadata  Py > \sql
Switching to SQL mode... Commands end with ;

 MySQL  cluster-rpi1:3306 ssl  mysql_innodb_cluster_metadata  SQL > SHOW VARIABLES LIKE '%ssl%';
+---------------------------------------------------+-----------------+
| Variable_name                                     | Value           |
+---------------------------------------------------+-----------------+
| group_replication_recovery_ssl_ca                 |                 |
| group_replication_recovery_ssl_capath             |                 |
| group_replication_recovery_ssl_cert               |                 |
| group_replication_recovery_ssl_cipher             |                 |
| group_replication_recovery_ssl_crl                |                 |
| group_replication_recovery_ssl_crlpath            |                 |
| group_replication_recovery_ssl_key                |                 |
| group_replication_recovery_ssl_verify_server_cert | OFF             |
| group_replication_recovery_use_ssl                | ON              |
| group_replication_ssl_mode                        | REQUIRED        |
| have_openssl                                      | YES             |
| have_ssl                                          | YES             |
| mysqlx_ssl_ca                                     |                 |
| mysqlx_ssl_capath                                 |                 |
| mysqlx_ssl_cert                                   |                 |
| mysqlx_ssl_cipher                                 |                 |
| mysqlx_ssl_crl                                    |                 |
| mysqlx_ssl_crlpath                                |                 |
| mysqlx_ssl_key                                    |                 |
| ssl_ca                                            | ca.pem          |
| ssl_capath                                        |                 |
| ssl_cert                                          | server-cert.pem |
| ssl_cipher                                        |                 |
| ssl_crl                                           |                 |
| ssl_crlpath                                       |                 |
| ssl_fips_mode                                     | OFF             |
| ssl_key                                           | server-key.pem  |
+---------------------------------------------------+-----------------+
27 rows in set (0.0391 sec)

 MySQL  cluster-rpi1:3306 ssl  mysql_innodb_cluster_metadata  SQL > SHOW VARIABLES LIKE '%white%';
+--------------------------------+-----------------+
| Variable_name                  | Value           |
+--------------------------------+-----------------+
| group_replication_ip_whitelist | 192.168.42.0/24 |
+--------------------------------+-----------------+
1 row in set (0.0383 sec)

 MySQL  cluster-rpi1:3306 ssl  SQL > SHOW VARIABLES LIKE 'group_replication%';
+-----------------------------------------------------+-------------------+
| Variable_name                                       | Value             |
+-----------------------------------------------------+-------------------+
| group_replication_allow_local_lower_version_join    | OFF               |
| group_replication_auto_increment_increment          | 7                 |
| group_replication_bootstrap_group                   | OFF               |
| group_replication_communication_debug_options       | GCS_DEBUG_NONE    |
| group_replication_components_stop_timeout           | 31536000          |
| group_replication_compression_threshold             | 1000000           |
| group_replication_enforce_update_everywhere_checks  | OFF               |
| group_replication_flow_control_applier_threshold    | 25000             |
| group_replication_flow_control_certifier_threshold  | 25000             |
| group_replication_flow_control_hold_percent         | 10                |
| group_replication_flow_control_max_quota            | 0                 |
| group_replication_flow_control_member_quota_percent | 0                 |
| group_replication_flow_control_min_quota            | 0                 |
| group_replication_flow_control_min_recovery_quota   | 0                 |
| group_replication_flow_control_mode                 | QUOTA             |
| group_replication_flow_control_period               | 1                 |
| group_replication_flow_control_release_percent      | 50                |
| group_replication_force_members                     |                   |
| group_replication_group_name                        | a587a3ad-7002-11e8-8612-b827eb2bc4f3  |
| group_replication_group_seeds                       |                   |
| group_replication_gtid_assignment_block_size        | 1000000           |
| group_replication_ip_whitelist                      | 192.168.42.0/24   |
| group_replication_local_address                     |                   |
| group_replication_member_weight                     | 50                |
| group_replication_poll_spin_loops                   | 0                 |
| group_replication_recovery_complete_at              | TRANSACTIONS_APPLIED           |
| group_replication_recovery_get_public_key           | ON                |
| group_replication_recovery_public_key_path          |                   |
| group_replication_recovery_reconnect_interval       | 60                |
| group_replication_recovery_retry_count              | 10                |
| group_replication_recovery_ssl_ca                   |                   |
| group_replication_recovery_ssl_capath               |                   |
| group_replication_recovery_ssl_cert                 |                   |
| group_replication_recovery_ssl_cipher               |                   |
| group_replication_recovery_ssl_crl                  |                   |
| group_replication_recovery_ssl_crlpath              |                   |
| group_replication_recovery_ssl_key                  |                   |
| group_replication_recovery_ssl_verify_server_cert   | OFF               |
| group_replication_recovery_use_ssl                  | OFF               |
| group_replication_single_primary_mode               | ON                |
| group_replication_ssl_mode                          | DISABLED          |
| group_replication_start_on_boot                     | OFF               |
| group_replication_transaction_size_limit            | 150000000         |
| group_replication_unreachable_majority_timeout      | 0                 |
+-----------------------------------------------------+-------------------+
44 rows in set (0.0340 sec)

Listing 9-9Displaying the Group Replication Variables

```

#### 保护路由器

既然我们已经为 SSL 和白名单配置了 MySQL 服务器，您可能想知道路由器需要做些什么。我们如何知道我们有从应用程序到路由器的 SSL 连接？

因为我们使用的是 MySQL 8.0.11 或更高版本，我们知道我们默认使用 SSL 连接，即使设置为需要 SSL 连接。因为我们更改了集群的名称，所以我们只需要做一个更改:我们必须编辑路由器配置文件以连接到正确的集群。打开路由器配置文件(例如，`/usr/local/mysql/lib/mysql-router/mysqlrouter.conf`)并更改清单 [9-10](#PC41) 中突出显示的集群名称。

```sql
# File automatically generated during MySQL Router bootstrap
[DEFAULT]
user=pi
logging_folder=/usr/local/mysql/lib/mysql-router/log
runtime_folder=/usr/local/mysql/lib/mysql-router/run
data_folder=/usr/local/mysql/lib/mysql-router/data
plugin_folder=/usr/local/mysql/lib/mysqlrouter
keyring_path=/usr/local/mysql/lib/mysql-router/data/keyring
master_key_path=/usr/local/mysql/lib/mysql-router/mysqlrouter.key
connect_timeout=30
read_timeout=30

[logger]
level = INFO

[metadata_cache:RPI_Cluster_SSL]

router_id=4
bootstrap_server_addresses=mysql://cluster-rpi1:3306,mysql://cluster-rpi2:3306,mysql://cluster-rpi3:3306,mysql://c
luster-rpi4:3306
user=mysql_router4_gnl6peiy2z2v

metadata_cluster=RPI_Cluster_SSL

ttl=5

[routing:RPI_Cluster_SSL_default_rw]

bind_address=0.0.0.0
bind_port=6446

destinations=metadata-cache://RPI_Cluster_SSL/default?role=PRIMARY

routing_strategy=round-robin
protocol=classic

[routing:RPI_Cluster_SSL_default_ro]

bind_address=0.0.0.0
bind_port=6447

destinations=metadata-cache://RPI_Cluster_SSL/default?role=SECONDARY

routing_strategy=round-robin
protocol=classic

[routing:RPI_Cluster_SSL_default_x_rw]

bind_address=0.0.0.0
bind_port=64460

destinations=metadata-cache://RPI_Cluster_SSL/default?role=PRIMARY

routing_strategy=round-robin
protocol=x

[routing:RPI_Cluster_SSL_default_x_ro]

bind_address=0.0.0.0
bind_port=64470

destinations=metadata-cache://RPI_Cluster_SSL/default?role=SECONDARY

routing_strategy=round-robin
protocol=x

Listing 9-10Change the Router Configuration File

```

请注意，我们将所有出现的`RPI_Cluster`更改为`RPI_Cluster_SSL`。您可以执行搜索并替换，或者，如果您想要创建新的路由器配置文件，您可以使用 Bootstrap 选项并指定新的配置文件，如下所示。注意使用了`--directory`选项来指定存储配置的新目录，使用了`--name`选项来指定配置的新名称。

```sql
$ sudo /usr/local/mysql/bin/mysqlrouter --bootstrap root@cluster-rpi4:3306 \
   --directory=/usr/local/mysql/lib/mysql-router-ssl/mysqlrouter.conf --user=pi \
   --name=router_rpi_ssl

```

在我们做出这些更改之后，我们可以通过使用配置文件(修改过的或者新的)重启路由器，并尝试我们的测试代码，如清单 [9-11](#PC43) 所示。您可以将该文件保存为`router_connect_test.py`。

```sql
import mysql.connector

# Simple function to display results from a cursor
def show_results(cur_obj):
  for row in cur_obj:
    print(row)

my_cfg = {
  'user':'root',
  'passwd':'secret',
  'host':'127.0.0.1',
  'port':6446
}

# Connecting to the server
conn = mysql.connector.connect(**my_cfg)

print("Listing the databases on the server.")
query = "SHOW DATABASES"
cur = conn.cursor()
cur.execute(query)
show_results(cur)

print("\nRetrieve the port for the server to which we're connecting.")
query = "SELECT @@port"
cur = conn.cursor()
cur.execute(query)
show_results(cur)

# Close the cursor and connection
cur.close()
conn.close()

Listing 9-11
Router Test Script

```

现在，我们运行 Python 脚本，应该会看到如下所示的输出。您可能认为代码会失败，但是在我们的集群中，客户端连接没有任何变化。因为我们使用的是 MySQL 8.0.11，SSL 连接在默认情况下是打开的。

```sql
$ python3 ./router_connect_test.py
('information_schema',)
('mysql',)
('mysql_innodb_cluster_metadata',)
('performance_schema',)
('shopping',)
('sys',)

```

就这样！我们刚刚通过启用 SSL 连接和使用白名单使我们的开发 InnoDB 集群更加安全。

## 摘要

对一个系统的真正考验是随着时间的推移它能被维护得多好。这种成功的一个重要因素是完成常规任务所需任务的复杂性。执行维护任务越容易，保持系统健康就越容易。同样，对于如何从导致需要修复或排除故障的错误或情况中恢复，有明确的任务也很重要。幸运的是，AdminAPI 拥有我们保持 InnoDB 集群良好运行所需的工具。

在本章中，您回顾了最常见的管理任务，查看了一组故障排除任务，并发现了一些与管理 InnoDB Cluster 相关的最佳实践。

下一章通过讨论部署 InnoDB Cluster 的注意事项以及为使用 MySQL 早期版本的用户准备迁移到 MySQL 8.0 来结束对 InnoDB Cluster 的介绍。

<aside class="FootnoteSection" epub:type="footnotes">Footnotes [1](#Fn1_source)

与黑名单相反，黑名单是你想要禁止的东西的列表。

  [2](#Fn2_source)

所有的数据对所有者来说不都是有价值的吗？

  [3](#Fn3_source)

我倾向于保存备份文件至少一个月，以防万一。

 </aside>