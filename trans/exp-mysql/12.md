# 十二、内部查询表示

本章介绍了数据库实验项目(DBXP)的高级数据库技术的第一部分。我首先介绍查询树结构的概念，它用于在内存中存储查询。接下来，我将展示这个项目使用的查询树结构，以及实现 DBXP 代码的一系列简短项目中的第一个。本章以一组练习结束，您可以使用这些练习来学习更多关于 MySQL 和查询树的知识。

查询树

查询树是对应于查询的树结构，其中树的叶节点包含访问关系的节点和具有零个、一个或多个子节点的内部节点。内部节点包含关系运算符。这些操作符包括 project(描述为π)、restrict(描述为σ)和 join(描述为θ或![image](img/symbol.jpg))。 [<sup> 1 </sup>](#Fn1) 树的边表示自下而上的数据流——即从对应于读取数据库中数据的树叶到生成查询结果的最终操作符根。[图 12-1](#Fig1) 描述了一个查询树的例子。

![9781430246596_Fig12-01.jpg](img/9781430246596_Fig12-01.jpg)

[图 12-1。](#_Fig1)示例查询树 [<sup>2</sup>](#Fn2)

对查询树的评估包括在操作数可用时评估内部节点操作，并将评估操作的结果沿树向上传递给父节点。当根节点被评估并被形成查询结果的元组替换时，评估终止。以下部分给出了用于在存储器中存储查询表示的查询树结构的变体。使用这种机制相对于关系演算内部表示的优势在[表 12-1](#Tab1) 中显示。

[表 12-1](#_Tab1) 。使用查询树相对于关系演算的优势

| 作战需求 | 查询树 | 关系演算 |
| --- | --- | --- |
| 可以减吗？ | 是的。可以在评估查询计划之前修剪查询树。 | 只有通过应用代数运算。 |
| 它能支持执行吗？ | 是的。该树可用于通过沿树向上传递数据来执行查询。 | 否。需要翻译成另一种形式。 |
| 它能支持关系代数表达式吗？ | 是的。这棵树非常适合关系代数。 | 否。需要转换。 |
| 它能在数据库系统中实现吗？ | 是的。树形结构是一种常见的数据结构。 | 只有通过模拟微积分的设计。 |
| 它能包含数据吗？ | 是的。树节点可以包含数据、操作和表达式。 | 没有。只有构成表达式的文字和变量。 |

显然，查询树内部表示优于现代数据库系统中采用的更传统的机制。例如，MySQL 中的内部表示是一组类和结构的表示，这些类和结构旨在包含查询及其元素，以便于(快速)遍历。它为优化和执行组织数据。 [<sup>3</sup>](#Fn3)

查询树内部表示有一些缺点。大多数优化器不是为在树形结构中工作而设计的。如果您想将查询树与优化器一起使用，就必须改变优化器。类似地，查询执行将与大多数查询处理实现非常不同。在这种情况下，查询执行引擎将从树中运行，而不是作为一个单独的步骤运行。这些缺点将在后面的章节中讨论，我将探索另一种优化器和执行引擎。

DBXP 查询树是使用节点结构的树数据结构，该节点结构包含表示这些操作所需的所有参数 :

*   *限制*:允许您包含匹配属性表达式的结果。
*   *Projection* :提供选择包含在结果集中的属性的能力。
*   *Join* :允许您组合两个或多个关系，在结果集中形成一组复合属性。
*   *Sort (order by)* :允许您对结果集进行排序。
*   *Distinct* :提供将结果集缩减为唯一元组的能力。

![image](img/sq.jpg) **注意** Distinct 是一个被添加来完成关系操作的操作，它不被大多数 SQL 实现所支持，也不是关系代数的固有属性。

投影、限制和连接是基本操作。Sort 和 distinct 作为附加的实用操作提供，有助于形成完整的查询树(所有可能的操作都表示为节点)。连接操作可以有连接条件(θ连接)或没有条件(等连接)。连接操作细分为以下操作:

*   *Inner* :返回元组的两个关系在匹配处的连接。
*   *Outer (left，right，full)* :返回`FROM`子句中提到的至少一个表或视图中的所有行，只要这些行满足任何`WHERE`搜索条件。所有行都是从用左外连接引用的左表中检索的，而右表中的所有行都在右外连接中引用。两个表中的所有行都在完全外部联接中返回。不匹配行的属性值作为空值返回。
*   *Leftouter* :两个关系的连接，返回匹配的元组，加上左边指定的关系中的所有元组，留下另一个关系中指定的不匹配属性为空(null)。
*   *Rightouter* :两个关系的连接，返回匹配的元组，加上右边指定的关系中的所有元组，留下另一个关系中指定的不匹配属性为空(null)。
*   *Fullouter* :两个关系的连接从两个关系中返回所有元组，将另一个关系中指定的不匹配属性留空(null)。
*   *交叉积*:两个关系的连接，将第一个关系中的每个元组映射到另一个关系中的所有元组。

查询树还支持一些集合操作。支持的集合操作包括:

*   *Intersect* :集合运算，只返回模式相同的两个关系的匹配。
*   *Union* :集合运算，其中只返回具有相同模式的两个关系的不匹配。

什么是θ连接？

你可能想知道为什么有些连接被称为等连接，而有些被称为θ连接 。相等联接是联接条件为相等(=)的联接。θ连接是一种连接条件是不等式的连接(>、<、> =、< =、< >)。从技术上讲，所有的连接都是θ连接。θ连接很少使用，而相等连接很常见。

虽然 DBXP 查询树提供了 union 和 intersect 操作，但大多数数据库系统都支持结果集串联形式的 union。尽管 MySQL 解析器目前不支持交集操作，但是它支持联合。需要进一步修改 MySQL 解析器来实现 intersect 操作。以下部分描述了将 MySQL 查询表示转换为 DBXP 查询树的主要代码实现和类。

查询转换

必须修改 MySQL 解析器来识别和解析 SQL 命令。然而，我们需要一种方法来告诉解析器我们想要使用 DBXP 实现，而不是现有的查询引擎。为了简化更改，我简单地在 SQL 命令中添加了一个关键字(例如 DBXP ),将解析重定向到将 MySQL 内部表示转换为 DBXP 内部表示的代码。尽管这个过程增加了一些执行时间，并且需要少量的额外计算工作，但是这个实现简化了对解析器的修改，并且提供了一个通用的机制来比较 DBXP 数据结构和 MySQL 数据结构。我将带有 DBXP 关键字的 SQL 命令简称为 DBXP SQL 命令。

转换 [<sup>4</sup>](#Fn4) 的过程始于 MySQL 解析器，它将命令识别为 DBXP 命令。然后，系统将控制权交给一个名为`sql_dbxp_parse.cc`的类，该类管理解析后的查询从 MySQL 形式到 DBXP 内部表示(查询树)的转换。这是通过名为`buid_query_tree`的方法完成的。这个方法只对`SELECT`和`EXPLAIN SELECT`语句调用。

DBXP 查询树

DBXP 查询优化器的核心是 DBXP 内部表示数据结构。它用于在 SQL 命令被解析和转换后表示查询。

这个结构被实现为一个树形结构(因此命名为*查询树*，其中每个节点有零个、一个或两个孩子。没有孩子的节点是树的叶子，有一个孩子的节点表示对数据执行一元操作的内部节点，有两个孩子的节点是连接或集合操作。源代码中的实际节点结构如[清单 12-1](#list1) 所示。

***[清单 12-1](#_list1) 。*** DBXP 查询树节点

```sql
/*
  STRUCTURE query_node

  DESCRIPTION
    This this structure contains all of the data for a query node:

    NodeId -- the internal id number for a node
    ParentNodeId -- the internal id for the parent node (used for insert)
    SubQuery -- is this the start of a subquery?
    Child -- is this a Left or Right child of the parent?
    NodeType -- synonymous with operation type
    JoinType -- if a join, this is the join operation
    join_con_type -- if this is a join, this is the "on" condition
    Expressions -- the expressions from the "where" clause for this node
    Join Expressions -- the join expressions from the "join" clause(s)
    Relations[] -- the relations for this operation (at most 4)
    PreemptPipeline -- does the pipeline need to be halted for a sort?
    Fields -- the attributes for the result set of this operation
    Left -- a pointer to the left child node
    Right -- a pointer to the right child node
*/
struct query_node
{
  query_node();
  ∼query_node();
  int                 nodeid;
  int                 parent_nodeid;
  bool                sub_query;
  bool                child;
  query_node_type     node_type;
  type_join           join_type;
  join_con_type       join_cond;
  Item                *where_expr;
  Item                *join_expr;
  TABLE_LIST          *relations[4];
  bool                preempt_pipeline;
  List<Item>          *fields;
  query_node          *left;
  query_node          *right;
};
```

其中一些变量用于管理节点组织和形成树本身。最有趣的两个是`nodeid`和`parent_nodeid`。这些用于建立树中节点的父子关系。这是必要的，因为作为优化过程的一部分，节点可以在树中上下移动。使用`parent_nodeid`变量避免了在树中维护反向指针的需要。 [<sup>5</sup>](#Fn5)

`sub_query`变量用于指示子查询的开始节点。因此，数据结构可以支持嵌套查询(子查询)，而无需对结构进行额外的修改。唯一需要注意的是，优化算法被设计成使用子查询指示符作为树遍历的停止条件。也就是说，当检测到子查询节点时，优化会将子查询视为一个单独的实体。一旦检测到，就使用子查询节点作为下一次优化的开始，重新运行查询优化例程。因此，可以支持任意数量的子查询，并将其表示为树结构中的子树。这是查询树的一个重要特性，它克服了许多内部表示的局限性。

`where_expr`变量是一个指向 MySQL `Item`树的指针，它管理一个典型的通用表达式树。稍后我们将把它改为一个封装表达式的特殊类。详见[第十三章](13.html)。

`relations`数组用于包含指向关系类的指针，这些关系类表示 MySQL 存储引擎中的内部记录结构的抽象。关系类通过存储引擎处理程序类提供对存储在磁盘上的数据的访问层。数组大小当前设置为 4。前两个位置(0 和 1)分别对应于左边和右边的孩子。接下来的两个位置(2 和 3)代表临时关系，比如重新排序(排序)和索引的应用。

![image](img/sq.jpg) **注意**`relations`数组大小设置为 4，这意味着您可以处理多达四个表的查询。如果您需要处理超过四个表的查询，您将需要更改本章后面显示的转换代码以接受超过四个表。

`fields`属性是指向 MySQL `Item`类的指针，该类包含一个表的字段列表。它在投影操作和维护关系操作所需的属性(例如，满足表达式但不是结果集一部分的属性的传播)中很有用。

最后一个感兴趣的变量是`preempt_pipeline`变量，DBXP `Execute`类使用它在处理来自子节点的数据时实现一个循环。每当操作需要遍历整个数据集(行)时，循环都是必要的。例如，在缺少允许排序的索引的情况下，联接一个公共属性上的两个关系的联接可能需要遍历一个或两个子节点，以便实现正确的映射(联接)操作。

这个类也负责查询优化(在[第 13 章](13.html)中描述)。由于查询树提供了操纵树的所有操作，并且由于查询优化也是一组树操作，因此优化是使用包装查询树结构的类(称为查询树类)中的方法来完成的。

优化器方法实现了一种启发式算法(在第 13 章的[中描述，在第 14 章](13.html)的[中有更详细的描述)。这些方法的执行导致将树重组为更优的树，并将一些节点分成两个或更多的其他节点，这些节点也可以被重新定位以形成更优的树。最佳树允许更有效地执行查询。](14.html)

该类还支持成本优化，使用遍历树的算法，将可用索引应用于每个叶节点(直接访问关系存储的节点)的访问方法。

这种结构可以支持各种各样的操作，包括限制、投影、连接、设置和排序(排序)。查询节点结构被设计为将这些操作中的每一个表示为单个节点，并且可以存储所有相关的和必需的信息以就地执行操作。此外，`EXPLAIN`命令被实现为树的后序遍历，从叶子开始打印出每个节点的内容(参见本章后面的`show_plan`方法)。这个操作的 MySQL 等价物需要更多的计算时间，并且是用一组复杂的方法实现的。

因此，查询树是一种内部表示，它可以表示任何查询，并提供一种通过操纵树来优化查询的机制。事实上，树结构本身简化了优化，并通过提供将查询操作关联为树中的节点的方式来实现启发式优化器。因此，该查询树是在任何关系数据库系统中使用的可行机制，并且可以推广到生产系统中使用。

在 MySQL 中实现 DBXP 查询树

本节展示了在 MySQL 源代码中添加的 DBXP 查询树结构。创建关系数据库研究工具的第一步旨在向您展示查询树是如何工作的，以及如何将 MySQL 查询结构转换为基本查询树(未优化)。后面的章节将描述优化器和执行引擎。

我们不会尝试重用现有的`SELECT`命令，而是在解析器中创建新的条目来实现带有字符串`DBXP_SELECT`的 SELECT 命令的特殊版本。这将允许修改被隔离，并且不会与解析器中现有的`SELECT`子组件混淆。接下来的部分向您展示了如何添加查询树和添加存根来执行`DBXP_SELECT`和`EXPLAIN DBXP_SELECT`命令。

![image](img/sq.jpg) **注意**Apress 网站上关于本章和后续章节的源代码示例包含一个差异文件，您可以用它来应用于 MySQL 源代码树。根据您所使用的服务器版本，如果它是基于 5.6 版的，那么修补操作只需做最小的修改就可以应用。差异文件的使用使示例代码更小，并允许您查看上下文中的变化。

添加和更改的文件

按照本章中的示例，您将创建几个文件并修改一些 MySQL 源代码文件。表 12-2 列出了将要添加和更改的文件。

[表 12-2](#_Tab2) 。添加和更改的文件摘要

| 文件 | 描述 |
| --- | --- |
| mysqld.cc | 在 MySQL 版本号上添加了 DBXP 版本号标签 |
| 莱克斯·h | 将 DBXP 标记添加到词法哈希中 |
| 查询 _ 树. h | DBXP 查询树头文件(新文件) |
| query_tree.cc | DBXP 查询树类文件(新文件) |
| sql_cmd.h | 将 DBXP_SELECT 添加到 enum_sql_command 列表 |
| sql_yacc.yy | 向解析器添加了 SQL 命令解析 |
| sql_parse.cc | 添加代码以处理“大交换机”的新命令 |

创建测试

以下部分解释了清除`DBXP_SELECT`命令的过程、查询树类以及`EXPLAIN DBXP_SELECT`和`DBXP_SELECT`命令。目标是允许用户输入任何有效的`SELECT`命令，处理查询，并返回结果。

![image](img/sq.jpg) **注意**由于 DBXP 引擎是一个实验性的引擎，它仅限于表示检索数据的基本操作的查询。将这些章节的长度保持在可管理的大小和复杂性要求 DBXP 引擎不处理带有聚集的查询——那些包含`HAVING`、`GROUP BY`或`ORDER BY`子句的查询。(没有任何东西禁止这样做，所以你可以自由地自己实现这些操作。)

下面几节详细介绍了创建 DBXP 代码的这三个方面所需的步骤。我将创建一个单独的测试文件并使用它来测试功能，而不是创建三个小的测试。对于那些未实现的操作，您可以通过在命令的开头添加井号(#)来注释掉查询语句，或者如图所示运行测试并忽略尚未实现的命令的不可避免的错误(从而遵守测试优先开发的原则)。清单 12-2 显示了`Ch12.test`文件。

***[清单 12-2](#_list2) 。*** 章节测试(Ch12.test)

```sql
#
# Sample test to test the DBXP_SELECT and EXPLAIN DBXP_SELECT commands
#

# Test 1: Test stubbed DBXP_SELECT command.
DBXP_SELECT * FROM no_such_table;

# Test 2: Test stubbed Query Tree implementation.
DBXP_SELECT * FROM customer;

# Test 3: Test stubbed EXPLAIN DBXP_SELECT command.
EXPLAIN DBXP_SELECT * FROM customer;
```

当然，您可以使用这个测试作为指南，并添加您自己的命令来探索新代码。有关如何使用 MySQL 测试套件创建和运行该测试的更多详细信息，请参考第 4 章。

清除 DBXP_SELECT 命令

在这一节中，您将学习如何向 MySQL 解析器添加一个定制的`SELECT`命令。您将看到如何修改解析器以适应一个新命令，该命令模拟 MySQL 中传统的`SELECT`命令。

识别修改

您应该首先通过在 MySQL 版本号上添加一个标签来识别一个拥有 DBXP 技术的 MySQL 服务器，以确保您总是能够分辨出您连接到的是经过修改的服务器。

![image](img/sq.jpg) **提示**你可以随时使用`SELECT VERSION()`命令来检索服务器的版本。如果您使用的是 MySQL 命令行客户端，您可以更改命令提示符，以指示您所连接的服务器是带有 DBXP 代码的服务器。

要添加版本标签，打开`mysqld.cc`文件并找到`set_server_version`方法。添加一条语句，将标签附加到 MySQL 版本号字符串上。在这种情况下，我们将使用“`-DBXP 2.0`”来代表这本书的印刷。[清单 12-3](#list3) 显示了修改后的`set_server_version`方法。

[***清单 12-3。***](#_list3) 修改 mysqld.cc 文件

```sql
static void set_server_version(void)
{
  char *end= strxmov(server_version, MYSQL_SERVER_VERSION,
                     MYSQL_SERVER_SUFFIX_STR, NullS);
#ifdef EMBEDDED_LIBRARY
  end= strmov(end, "-embedded");
#endif
#ifndef DBUG_OFF
  if (!strstr(MYSQL_SERVER_SUFFIX_STR, "-debug"))
    end= strmov(end, "-debug");
#endif
  if (opt_log || opt_slow_log || opt_bin_log)
    strmov(end, "-log");                        // This may slow down system
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section adds the DBXP version number to the MySQL version number. */
  strmov(end, "-DBXP 2.0");
/* END DBXP MODIFICATION */
}
```

修改词汇结构

现在，让我们添加标识`DBXP_SELECT`命令所需的标记。打开`lex.h`文件，将[清单 12-4](#list4) 中粗体显示的代码添加到上下文中的`symbols`数组中。

***[清单 12-4](#_list4) 。*** 对 lex.h 文件的修改

```sql
static SYMBOL symbols[] = {
...
  { "DAY_MINUTE",       SYM(DAY_MINUTE_SYM)},
  { "DAY_SECOND",       SYM(DAY_SECOND_SYM)},
/* BEGIN DBXP MODIFICATION */
/* Reason for MODIFICATION */
/* This section identifies the symbols and values for the DBXP token */
  { "DBXP_SELECT",       SYM(DBXP_SELECT_SYM)},
/* END DBXP MODIFICATION */
  { "DEALLOCATE",       SYM(DEALLOCATE_SYM)},
  { "DEC", SYM(DECIMAL_SYM)},
```

。。。

添加命令枚举

本节解释如何添加新的`DBXP_SELECT`命令枚举。修改从在`sql_parse.cc`文件中向解析器命令开关添加一个新的 case 语句开始。开关使用事例的枚举值。

要添加新案例，您必须添加新的枚举值。这些值在解析器代码中被识别，并存储在`lex->sql_command`成员变量中。要向词法分析器添加新的枚举值，打开`sql_cmd.h`文件，并将清单 12-5 中的[代码添加到`enum_sql_command`枚举中。](#list5)

***[清单 12-5](#_list5) 。*** 添加 DBXP_SELECT 命令枚举

```sql
enum enum_sql_command {
...
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section captures the enumerations for the DBXP command tokens */
  SQLCOM_DBXP_SELECT,
  SQLCOM_DBXP_EXPLAIN_SELECT,
/* END DBXP MODIFICATION */
...
```

将 DBXP_SELECT 命令添加到 MySQL 解析器

一旦为 case 语句添加了新的枚举值，您还必须向解析器代码(`sql_yacc.yy`)添加代码，以标识新的`DBXP_SELECT`语句。这分几个部分完成。您将向解析器添加一个新的令牌，需要对三个地方进行更新。

新的令牌一旦被激活，将允许解析器区分普通的 MySQL `SELECT`语句和您想要用 DBXP 代码处理的语句。我们对解析器进行编程，以便当令牌存在时，它指示解析器应该将`sql_command`变量设置为`SQLCOM_DBXP_SELECT`值，而不是普通的 MySQL select 枚举值(`SQLCOM_SELECT`)。这种技术允许您向普通的 MySQL 代码和 DBXP 代码发出相同的基本`SELECT`语句。例如，下面的`SELECT`语句都完成相同的任务；它们只是被不同地优化了。第一个将指向`SQLCOM_SELECT` case 语句，而第二个将指向`SQLCOM_DBXP_SELECT` case 语句。

```sql
SELECT * FROM customer;
DBXP_SELECT * FROM customer;
```

添加新令牌的代码如清单 12-6 所示。在`sql_yacc.yy`文件中找到令牌列表并添加代码。(名单大致按字母顺序排列)。

***[清单 12-6](#_list6) 。*** 给解析器添加命令符号

```sql
%token  DAY_SECOND_SYM
%token  DAY_SYM                       /* SQL-2003-R */
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section defines the tokens for the DBXP commands */
%token  DBXP_SELECT_SYM
/* END DBXP MODIFICATION */
%token  DEALLOCATE_SYM                /* SQL-2003-R */
%token  DECIMAL_NUM
```

我们还需要将新命令添加到类型<none>定义中。清单 12-7 展示了这一修改。</none>

***[清单 12-7](#_list7) 。*** 向解析器添加命令语法操作

```sql
%type <NONE>
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* Add the dbxp_select statement to the NONE type definition. */
        query verb_clause create change select dbxp_select do drop insert replace insert2
/* END DBXP MODIFICATION */
```

添加令牌的最后一个区域是将以下代码添加到语句部分。清单 12-8 显示了上下文中的修改。

***[清单 12-8](#_list8) 。*** 向选择部分添加命令

```sql
statement:
...
        | select
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* Add the dbxp_select statement to the list of statements(commands). */
        | dbxp_select
/* END DBXP MODIFICATION */
        | set
...
```

我们现在可以添加语句来解析 DBXP_SELECT 命令。清单 12-9 显示了识别`DBXP_SELECT`命令和处理 select 命令的普通部分所需的解析器代码。注意，解析器识别 select 和 DBXP 符号，然后提供 select 选项、字段列表和`FROM`子句的其他解析。紧跟在那一行之后的是设置`sql_command`的代码。请注意，该代码还在原始 select-command 解析器代码前放置了一个竖线(|)。这是解析器语法用来处理命令变体的“or”运算符。要将这一更改添加到解析器中，打开`sql_yacc.yy`文件并定位`select:`标签，然后添加代码，如[清单 12-9](#list9) 所示。

***[清单 12-9](#_list9) 。*** 向解析器添加命令语法操作

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section captures (parses) the SELECT DBXP statement */

dbxp_select:
         DBXP_SELECT_SYM DBXP_select_options DBXP_select_item_list
                 DBXP_select_from
         {
             LEX *lex= Lex;
           lex->sql_command = SQLCOM_DBXP_SELECT;
         }
         ;

/* END DBXP MODIFICATION */

select:
         select_init
          {
            LEX *lex= Lex;
            lex->sql_command= SQLCOM_SELECT;
          }
        ;
```

还要注意，代码引用了其他几个标签。清单 12-10 包含了这些操作的代码。第一个是`DBXP_select_options`，它标识了`SELECT`命令的有效选项。虽然这与 MySQL select 选项非常相似，但它只提供了两个选项:`DISTINCT`和`COUNT(*)`。下一个操作是识别`FROM`子句中的表的`DBXP_select_from`代码。它还调用`DBXP_where_clause`操作来识别`WHERE`子句。下一个操作是`DBXP_select_item_list`，它类似于 MySQL 代码。最后，`DBXP_where_clause`操作标识了`WHERE`子句中的参数。花些时间浏览这段代码，并按照操作找到它们相关的标签，看看每个标签都做了什么。要将这段代码添加到解析器中，找到`select_from:`标签并在它上面添加代码。尽管将代码放在哪里并不重要，但是这个位置似乎更符合逻辑，因为它与 MySQL select 操作位于同一区域。[清单 12-10](#list10) 显示了`DBXP_SELECT`解析器代码的完整源代码。

***[清单 12-10](#_list10) 。*T5【附加操作】为 DBXP_SELECT 命令**

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section captures (parses) the sub parts of the SELECT DBXP statement */

DBXP_select_options:
   /* empty */
   | DISTINCT
   {
     Select->options|= SELECT_DISTINCT;
   }
  ;

DBXP_select_from:
  FROM join_table_list DBXP_where_clause {};

DBXP_select_item_list:
  /* empty */
  | DBXP_select_item_list ',' select_item
  | select_item
  | '*'
    {
      THD *thd= YYTHD;
      Item *item= new (thd->mem_root)
                    Item_field(&thd->lex->current_select->context,
                               NULL, NULL, "*");
      if (item == NULL)
        MYSQL_YYABORT;
      if (add_item_to_list(thd, item))
        MYSQL_YYABORT;
      (thd->lex->current_select->with_wild)++;
    };

DBXP_where_clause:
  /* empty */  { Select->where= 0; }
   | WHERE expr
    {
      SELECT_LEX *select= Select;
      select->where= $2;
      if ($2)
        $2->top_level_item();
    }
    ;

/* END DBXP MODIFICATION */

...
```

![image](img/sq.jpg) **注意**一个精明的 yacc 开发人员可能会发现代码中的一些地方，可以从原始 SELECT 语句的规则中减少或重用。对于那些对优化这段代码感兴趣的人来说，我把它作为一个练习。

既然您已经对词法分析器进行了更改，那么您必须生成等价的 C 源代码。幸运的是，正常的 cmake/make 步骤会解决这个问题。只需从源代码树的根执行这些命令。

```sql
cmake .
make
```

如果您想在不等待 make 文件处理所有源文件的情况下检查您的代码，您可以使用 Bison 来生成这些文件。打开一个命令窗口，导航到源代码树根下的`/sql`目录。运行命令:

```sql
bison -y -d sql_yacc.yy
```

这会生成两个新文件:`y.tab.c`和`y.tab.h`。这些文件分别替换了`sql_yacc.cc`和`sql_yacc.h`文件。在复制它们之前，请备份原始文件。完成后，将`y.tab.c`复制到`sql_yacc.cc`，将`y.taqb.h`复制到`sql_yacc.h`。

莱克斯和 YACC 是什么，拜辛是谁？

Lex 代表“词法分析器生成器”,用作解析器来识别标记和文字，以及语言的语法。YACC 代表“又一个编译器”,用于识别和处理语言的语义定义。这些工具与 Bison(一个 YACC 兼容的解析器生成器，它从 Lex/YACC 代码生成 C 源代码)一起使用，为创建能够解析和处理语言命令的子系统提供了丰富的机制。事实上，这正是 MySQL 使用这些技术的方式。

如果您现在编译服务器，您可以发出`DBXP_SELECT`命令，但是什么也不会发生。这是因为您需要将 case 语句添加到`sql_parse.cc`中的解析器开关中。因为我们还没有一个完整的 DBXP 引擎，所以让我们通过删除 case 语句来使这个练习更有趣一些。清单 12-11 显示了一套完整的脚手架代码，你可以用它来实现`DBXP_SELECT`命令。在这段代码中，我使用 MySQL 实用程序类来建立一个记录集。代码的第一部分为虚拟表设置字段列表。接下来是将数据值写入网络流的代码行，最后，向客户端发送一个文件结束标记。将数据写入输出流需要调用`protocol->prepare_for_resend()`，使用`protocol->store()`存储要发送的数据，然后使用`protocol->write()`将缓冲区写入流。

***[清单 12-11](#_list11) 。*** 修改解析器命令开关

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new DBXP_SELECT command. */
  case SQLCOM_DBXP_SELECT:
  {
    List<Item> field_list;
    /* The protocol class is used to write data to the client. */
    Protocol *protocol= thd->protocol;
    /* Build the field list and send the fields to the client */
    field_list.push_back(new Item_int("Id",(longlong) 1,21));
    field_list.push_back(new Item_empty_string("LastName",40));
    field_list.push_back(new Item_empty_string("FirstName",20));
    field_list.push_back(new Item_empty_string("Gender",2));
    if (protocol->send_ result_set_metadata (&field_list,
                              Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
      DBUG_RETURN(TRUE);
    protocol->prepare_for_resend();
    /* Write some sample data to the buffer and send it with write() */
    protocol->store((longlong)3);
    protocol->store("Flintstone", system_charset_info);
    protocol->store("Fred", system_charset_info);
    protocol->store("M", system_charset_info);
    if (protocol->write())
      DBUG_RETURN(TRUE);
    protocol->prepare_for_resend();
    protocol->store((longlong)5);
    protocol->store("Rubble", system_charset_info);
    protocol->store("Barnie", system_charset_info);
    protocol->store("M", system_charset_info);
    if (protocol->write())
      DBUG_RETURN(TRUE);

    protocol->prepare_for_resend();
    protocol->store((longlong)7);
    protocol->store("Flintstone", system_charset_info);
    protocol->store("Wilma", system_charset_info);
    protocol->store("F", system_charset_info);
    if (protocol->write())
      DBUG_RETURN(TRUE);

    /*
      send_eof() tells the communication mechanism that we're finished
      sending data (end of file).
    */
    my_eof(thd);
    break;
  }
/* END DBXP MODIFICATION */
  case SQLCOM_PREPARE:
...
```

每当检测到一个`DBXP_SELECT`命令时，这个存根代码就向客户机返回一个模拟记录集。继续输入这段代码，然后编译并运行测试。

测试 DBXP_SELECT 命令

我们想要运行的测试是发出一个`DBXP_SELECT`命令，并验证该语句是否被新的存根 case 语句解析和处理。您可以运行之前创建的测试，或者只需在 MySQL 命令行客户端中输入如下 SQL 语句(确保键入 DBXP 部分):

```sql
DBXP_SELECT * from no_such_table;
```

只要是有效的 SQL `SELECT`语句，在 DBXP 之后键入什么并不重要。清单 12-12 展示了一个你应该期待的输出的例子。

***[清单 12-12](#_list12) 。*** 存根测试结果

```sql
mysql> DBXP_SELECT * from no_such_table;
+----+------------+-----------+--------+
| Id | LastName   | FirstName | Gender |
+----+------------+-----------+--------+
| 3  | Flintstone | Fred      | M      |
| 5  | Rubble     | Barnie    | M      |
| 7  | Flintstone | Wilma     | F      |
+----+------------+-----------+--------+
3 rows in set (0.23 sec)

mysql>
```

添加查询树类

现在您已经有了一个存根`DBXP_SELECT`命令，您可以开始实现特定于 DBXP 的代码来执行一个`SELECT`命令。在这一节中，我将向您展示如何添加基本的查询树类并将 MySQL 内部结构转换为查询树。在下一章之前，我不会深入到查询树代码的内部。

添加查询树头文件

添加查询树类需要创建查询树头文件，并在 MySQL 代码中引用它。查询树头文件如[清单 12-13](#list13) 所示。请注意，我将该类命名为`Query_tree`。这遵循了 MySQL 编码准则，用首字母大写来命名类。花点时间浏览一下标题代码。您会看到这里没有太多代码——只有查询树节点结构和枚举的基础。注意，节点类型、连接条件类型、连接和聚集类型都有枚举。这些枚举允许查询树节点在查询的执行中承担独特的角色。我将在下一章详细解释如何使用它们。

您可以选择任何方式创建文件(或下载)。将其命名为`query_tree.h`，并将其放在 MySQL 源代码树的`/sql`目录中。不要担心如何将其添加到项目中；我将在后面的部分向您展示如何做到这一点。

***[清单 12-13](#_list13) 。*** *查询树头文件*

```sql
/*
  query_tree.h

  DESCRIPTION
    This file contains the Query_tree class declaration. It is responsible for containing the
    internal representation of the query to be executed. It provides methods for
    optimizing and forming and inspecting the query tree. This class is the very
    heart of the DBXP query capability! It also provides the ability to store
    a binary "compiled" form of the query.

  NOTES
    The data structure is a binary tree that can have 0, 1, or 2 children. Only
    Join operations can have 2 children. All other operations have 0 or 1
    children. Each node in the tree is an operation and the links to children
    are the pipeline.

  SEE ALSO
    query_tree.cc
*/
#include "sql_priv.h"
#include "sql_class.h"
#include "table.h"
#include "records.h"

class Query_tree
{
public:
  enum query_node_type          //this enumeration lists the available
  {                              //query node (operations)
    qntUndefined = 0,
    qntRestrict = 1,
    qntProject = 2,
    qntJoin = 3,
    qntSort = 4,
    qntDistinct = 5
  };

  enum join_con_type            //this enumeration lists the available
  {                              //join operations supported
    jcUN = 0,
    jcNA = 1,
    jcON = 2,
    jcUS = 3
  };

  enum type_join                //this enumeration lists the available
  {                              //join types supported.
    jnUNKNOWN      = 0,          //undefined
    jnINNER        = 1,
    jnLEFTOUTER    = 2,
    jnRIGHTOUTER   = 3,
    jnFULLOUTER    = 4,
    jnCROSSPRODUCT = 5,
    jnUNION        = 6,
    jnINTERSECT    = 7
  };

    enum AggregateType          //used to add aggregate functions
    {
        atNONE      = 0,
        atCOUNT     = 1
    };

  /*
    STRUCTURE query_node

    DESCRIPTION
      This this structure contains all of the data for a query node:

      NodeId -- the internal id number for a node
      ParentNodeId -- the internal id for the parent node (used for insert)
      SubQuery -- is this the start of a subquery?
      Child -- is this a Left or Right child of the parent?
      NodeType -- synonymous with operation type
      JoinType -- if a join, this is the join operation
      join_con_type -- if this is a join, this is the "on" condition
      Expressions -- the expressions from the "where" clause for this node
      Join Expressions -- the join expressions from the "join" clause(s)
      Relations[] -- the relations for this operation (at most 2)
      PreemptPipeline -- does the pipeline need to be halted for a sort?
      Fields -- the attributes for the result set of this operation
      Left -- a pointer to the left child node
      Right -- a pointer to the right child node
*/
  struct query_node
  {
    query_node();
    ∼query_node();
    int                 nodeid;
    int                 parent_nodeid;
    bool                sub_query;
    bool                child;
    query_node_type     node_type;
    type_join           join_type;
    join_con_type       join_cond;
    Item                *where_expr;
    Item                *join_expr;
    TABLE_LIST          *relations[4];
    bool                preempt_pipeline;
    List<Item>          *fields;
    query_node          *left;
    query_node          *right;
  };

  query_node *root;              //The ROOT node of the tree

  ∼Query_tree(void);
  void ShowPlan(query_node *QN, bool PrintOnRight);

};
```

有了查询树头文件，您还需要查询树源文件。源文件必须提供查询树类的构造函数和析构函数方法的代码。[清单 12-14](#list14) 展示了完整的构造函数和析构函数方法。创建`query_tree.cc`文件，输入这个代码(或者下载)。将这个文件放在 MySQL 源代码树的`/sql`目录中。在后面的小节中，我将向您展示如何将它添加到项目中。

***[清单 12-14](#_list14) 。*** 查询树类

```sql
/*
  query_tree.cc

  DESCRIPTION
    This file contains the Query_tree class. It is responsible for containing the
    internal representation of the query to be executed. It provides methods for
    optimizing and forming and inspecting the query tree. This class is the very
    heart of the DBXP query capability! It also provides the ability to store
    a binary "compiled" form of the query.

  NOTES
    The data structure is a binary tree that can have 0, 1, or 2 children. Only
    Join operations can have 2 children. All other operations have 0 or 1
    children. Each node in the tree is an operation and the links to children
    are the pipeline.

  SEE ALSO
    query_tree.h
*/
#include "query_tree.h"

Query_tree::query_node::query_node()
{
  where_expr = NULL;
  join_expr = NULL;
  child = false;
  join_cond = Query_tree::jcUN;
  join_type = Query_tree::jnUNKNOWN;
  left = NULL;
  right = NULL;
  nodeid = -1;
  node_type = Query_tree::qntUndefined;
  sub_query = false;
  parent_nodeid = -1;
}

Query_tree::query_node::∼query_node()
{
  if(left)
    delete left;
  if(right)
    delete right;
}

Query_tree::∼Query_tree(void)
{
  if(root)
    delete root;
}
```

从 MySQL 结构构建查询树

接下来我们需要的是执行从 MySQL 内部结构到查询树的转换的代码。让我们使用一个助手源文件，而不是将代码添加到`sql_parse.cc`文件中。事实上，case 语句(在`sql_parse.cc`文件中)表示的许多命令都是这样完成的。创建一个名为`sql_dbxp_parse.cc`的新文件。在名为`build_query_tree`的文件中创建一个新函数，如[清单 12-15](#list15) 所示。代码是一个基本的转换方法。输入代码时，花点时间浏览一下代码(或者下载并复制粘贴到文件中)。

***[清单 12-15](#_list15) 。***DBXP 解析器辅助文件

```sql
/*
  sql_dbxp_parse.cc

  DESCRIPTION
    This file contains methods to execute the DBXP_SELECT query statements.

  SEE ALSO
    query_tree.cc
*/
#include "query_tree.h"

/*
  Build Query Tree

  SYNOPSIS
    build_query_tree()
    THD *thd            IN the current thread
    LEX *lex            IN the pointer to the current parsed structure
    TABLE_LIST *tables  IN the list of tables identified in the query

  DESCRIPTION
    This method returns a converted MySQL internal representation (IR) of a
    query as a query_tree.

  RETURN VALUE
    Success = Query_tree * -- the root of the new query tree.
    Failed = NULL
*/
Query_tree *build_query_tree(THD *thd, LEX *lex, TABLE_LIST *tables)
{
  DBUG_ENTER("build_query_tree");
  Query_tree *qt = new Query_tree();
  Query_tree::query_node *qn = new Query_tree::query_node();
  TABLE_LIST *table;
  int i = 0;
  int num_tables = 0;

  /* Create a new restrict node. */
  qn->parent_nodeid = -1;
  qn->child = false;
  qn->join_type = (Query_tree::type_join) 0;
  qn->nodeid = 0;
  qn->node_type = (Query_tree::query_node_type) 2;
  qn->left = 0;
  qn->right = 0;

  /* Get the tables (relations) */
  i = 0;
  for(table = tables; table; table = table->next_local)
  {
    num_tables++;
    qn->relations[i] = table;
    i++;
  }

  /* Populate attributes */
  qn->fields = &lex->select_lex.item_list;
  /* Process joins */
  if (num_tables > 0)  //indicates more than 1 table processed
    for(table = tables; table; table = table->next_local)
      if (((Item *)table->join_cond() != 0) && (qn->join_expr == 0))
        qn->join_expr = (Item *)table->join_cond();
  qn->where_expr = lex->select_lex.where;
  qt->root = qn;
  DBUG_RETURN(qt);
}
```

注意，`build_query_tree`代码从创建一个新的查询节点开始，标识查询中使用的表，填充字段列表，并捕获`join`和`where`表达式。这些都是执行最基本的查询所需的基本项目。

阻止查询树执行

现在让我们考虑用代码创建一个查询树需要什么。创建一个名为`DBXP_select_command`的新函数，并复制[清单 12-16](#list16) 中的代码。将这个函数放在`sql_dbxp_parse.cc`文件中。该函数将从`sql_parse.cc`中的 case 语句中调用。

***[清单 12-16](#_list16) 。*T5 处理 DBXP_SELECT 命令**

```sql
/*
  Perform Select Command

  SYNOPSIS
    DBXP_select_command()
    THD *thd            IN the current thread

  DESCRIPTION
    This method executes the SELECT command using the query tree.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int DBXP_select_command(THD *thd)
{
  DBUG_ENTER("DBXP_select_command");
  Query_tree *qt = build_query_tree(thd, thd->lex,
                                    (TABLE_LIST*) thd->lex->select_lex.table_list.first);
  List<Item> field_list;
  Protocol *protocol= thd->protocol;
  field_list.push_back(new Item_empty_string("Database Experiment Project (DBXP)",40));
  if (protocol->send_result_set_metadata(&field_list,
                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
    DBUG_RETURN(TRUE);
  protocol->prepare_for_resend();
  protocol->store("Query tree was built.", system_charset_info);
  if (protocol->write())
    DBUG_RETURN(TRUE);
  my_eof(thd);
  DBUG_RETURN(0);
}
```

这段代码首先调用转换函数(`build_query_tree`)，然后创建一个存根结果集。这一次，我创建了一个只有一列一行的记录集，用于向客户机传递查询树转换完成的消息。虽然这段代码不是很有趣，但它是一个占位符，让您可以在查询树上进行更多的实验(参见本章末尾的练习)。将`sql_dbxp_parse.cc`文件放在 MySQL 源代码树的`/sql`目录中。

重新访问 DBXP_SELECT 命令

打开`sql_parse.cc`文件，为`DBXP_select_command`函数添加一个函数声明，将声明放在短语`mysql_execute_command`附近。[清单 12-17](#list17) 显示了`DBXP_select_command`函数的完整函数头。在注释块上方输入此代码，如下所示。

***[清单 12-17](#_list17) 。*** 修改解析器命令代码

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new SELECT DBXP command. */
int DBXP_select_command(THD *thd);
int DBXP_explain_select_command(THD *thd);
/* END DBXP MODIFICATION */
```

您现在可以更改 case 语句中的代码(也称为解析器命令开关)来调用新的`DBXP_select_command`函数。[清单 12-18](#list18) 显示了调用这个函数的完整代码。注意，我们需要传入的唯一参数是当前线程(`thd`)。MySQL 内部查询结构和查询的所有其他元数据都是通过线程指针引用的。如您所见，这种技术大大简化了 case 语句。这也有助于模块化 DBXP 代码，使其更容易维护和修改您的实验。

***[清单 12-18](#_list18) 。*** 修改解析命令开关(sql_parse.cc)

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new DBXP_SELECT command. */
  case SQLCOM_DBXP_SELECT:
  {
    res = DBXP_select_command(thd);
    if (res)
      goto error;
    break;
  }
/* END DBXP MODIFICATION */
  case SQLCOM_PREPARE:
  {
...
```

在编译服务器之前，您需要用将新的源代码文件(`query_tree.h`、`query_tree.cc`和`sql_dbxp_parse.cc`)添加到项目(make)文件中。

将文件添加到 CMakeLists.txt 文件中

添加项目文件需要从源代码树的根目录修改`/sql`目录中的`CMakeLists.txt`文件。打开文件并找到 SQL_SHARED_SOURCES `_`标签。将源代码文件添加到服务器编译的源代码列表中(`mysqld`)。[清单 12-19](#list19) 显示了定义的开始和添加的项目文件。

***[清单 12-19](#_list19) 。*T5 对 CMakeLists.txt 文件的修改**

```sql
SET(SQL_SHARED_SOURCES
  abstract_query_plan.cc
  datadict.cc
...
  sql_dbxp_parse.cc
  query_tree.cc
...
```

![image](img/sq.jpg) **注意**修改 cmake 文件时，格式化列表时一定要使用空格。

测试查询树

一旦服务器编译无误，就可以使用 SQL 语句对其进行测试。与上一个测试不同，您应该输入一个引用现有对象的有效 SQL 命令。您可以如前一节所述运行测试(参见[清单 12-20](#list20) ),或者在 MySQL 命令行客户端中输入以下命令:

```sql
DBXP_SELECT * from customer;
```

***[清单 12-20](#_list20) 。***DBXP _ SELECT 测试的结果

```sql
mysql> DBXP_SELECT * FROM customer;

+--------------------------------------------------+
| Database Experiment Project (DBXP)               |
+--------------------------------------------------+
| Query tree was built.                            |
+--------------------------------------------------+
1 row in set (0.00 sec)

mysql>
```

您已经取消了`DBXP_SELECT`操作并构建了一个查询树，但是这并不有趣。如果我们能看到查询的样子会怎么样呢？我们将创建一个类似于`EXPLAIN`命令的函数，只是我们将创建一个树形查询的图形表示 [<sup>6</sup>](#Fn6) ，而不是查询的信息列表。

显示查询树的详细信息

添加新命令需要在`sql_parse.cc`的解析器开关中为新的 case 语句添加新的枚举，并添加解析器代码来标识新命令。您还必须向`sql_DBXP_parse.cc`文件添加执行新命令的代码。虽然创建并向解析器添加解释查询树的`EXPLAIN`命令听起来很复杂，但是`EXPLAIN SELECT`命令在 MySQL 中是可用的，因此我们可以复制大量代码并重用其中的大部分。

向 MySQL 解析器添加 EXPLAIN DBXP_SELECT 命令

要向解析器添加新的枚举，打开`sql_lex.h`文件，在`SQLCOM_DBXP_SELECT`枚举的代码后面添加一个名为`SQLCOM_DBXP_EXPLAIN_SELECT`的枚举。清单 12-21 显示了完整的代码变更。一旦添加了代码，就可以像前面描述的那样重新生成词法哈希。

***[清单 12-21](#_list21) 。*T5】添加解释枚举**

```sql
/* A Oracle compatible synonym for show */
describe:
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section captures (parses) the EXPLAIN (DESCRIBE) DBXP statements */

  describe_command DBXP_SELECT_SYM DBXP_select_options DBXP_select_item_list
                 DBXP_select_from
  {
          LEX *lex= Lex;
          lex->sql_command = SQLCOM_DBXP_EXPLAIN_SELECT;
          lex->select_lex.db= 0;
          lex->verbose= 0;
  }

/* END DBXP MODIFICATION */
...
```

注意，在这段代码中，解析器识别了一个`EXPLAIN DBXP_SELECT`命令。事实上，它调用了许多与`DBXP_SELECT`解析器代码相同的操作。唯一的区别是这段代码将`sql_command`设置为新的枚举(`SQLCOM_DBXP_EXPLAIN_SELECT`)。

对`sql_parse.cc`中解析器开关语句的修改需要为`sql_DBXP_parse.cc`中执行`EXPLAIN`命令的代码添加函数声明。打开`sql_parse.cc`文件，为`EXPLAIN`函数添加函数声明。说出函数的名字`DBXP_explain_select_command`(你开始看到一个模式了吗？).将它添加到与`DBXP_select_command`函数声明相同的位置。清单 12-22 显示了两个 DBXP 命令的完整代码。

***[清单 12-22](#_list22) 。*T5】修改解析器命令代码**

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new DBXP_SELECT command. */
int DBXP_select_command(THD *thd);
int DBXP_explain_select_command(THD *thd);
/* END DBXP MODIFICATION */
```

还需要为 DBXP explain 命令添加新的 case 语句。这些语句类似于`DBXP_SELECT`命令的 case 语句。[清单 12-23](#list23) 显示了添加的新 case 语句。

***[清单 12-23](#_list23) 。*T5】对解析器切换语句的修改**

```sql
/* BEGIN DBXP MODIFICATION */
/* Reason for Modification: */
/* This section adds the code to call the new DBXP_SELECT command. */
  case SQLCOM_DBXP_SELECT:
  {
    res = DBXP_select_command(thd);
    if (res)
      goto error;
    break;
  }
  case SQLCOM_DBXP_EXPLAIN_SELECT:
  {
    res = DBXP_explain_select_command(thd);
    if (res)
      goto error;
    break;
  }
/* END DBXP MODIFICATION */
```

创建 show_plan 函数

`EXPLAIN DBXP_SELECT`命令将查询路径显示为在字符文本范围内打印出来的树。在`sql_DBXP_parse.cc`文件中名为`show_plan`的函数中执行`EXPLAIN`代码。一个名为`write_printf`的辅助函数用于使`show_plan`代码更容易阅读。[清单 12-24](#list24) 和 [12-25](#list25) 显示了这两种方法的完整代码。

***[清单 12-24](#_list24) 。*** 增加一个函数来捕获协议存储和写语句

```sql
/*
  Write to vio with printf.

  SYNOPSIS
    write_printf()
    Protocol *p     IN the Protocol class
    char *first     IN the first string to write
    char *last      IN the last string to write

  DESCRIPTION
    This method writes to the vio routines printing the strings passed.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int write_printf(Protocol *p, char *first, const char *last)
{
  char *str = new char[1024];

  DBUG_ENTER("write_printf");
  strcpy(str, first);
  strcat(str, last);
  p->prepare_for_resend();
  p->store(str, system_charset_info);
  p->write();
  delete str;
  DBUG_RETURN(0);
}

```

请注意，`write_printf`代码调用了`protocol->store`和`protocol->write`函数向客户端写入一行绘图。我将让您探索清单 12-25 中的[源代码，看看它是如何工作的。在下一节中，我将向您展示一个代码执行的示例。该代码使用后序遍历从查询树的根开始生成查询计划。将这些方法添加到`sql_DBXP_parse.cc`文件中。](#list25)

***[清单 12-25](#_list25) 。*T5 展示 _ 计划源代码**

```sql
/*
  Show Query Plan

  SYNOPSIS
    show_plan()
    Protocol *p         IN the MySQL protocol class
    query_node *Root    IN the root node of the query tree
    query_node *qn      IN the starting node to be operated on.
    bool print_on_right IN indicates the printing should tab to the right
                           of the display.

  DESCRIPTION
    This method prints the execute plan to the client via the protocol class

  WARNING
    This is a RECURSIVE method!
    Uses postorder traversal to draw the quey plan

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int show_plan(Protocol *p, Query_tree::query_node *root,
              Query_tree::query_node *qn, bool print_on_right)
{
  DBUG_ENTER("show_plan");

  /* spacer is used to fill white space in the output */
  char *spacer = (char *)my_malloc(80, MYF(MY_ZEROFILL | MY_WME));
  char *tblname = (char *)my_malloc(256, MYF(MY_ZEROFILL | MY_WME));
  int i = 0;

  if(qn != 0)
  {
    show_plan(p, root, qn->left, print_on_right);
    show_plan(p, root, qn->right, true);
    /* draw incoming arrows */
    if(print_on_right)
      strcpy(spacer, "          |               ");
    else
      strcpy(spacer, "     ");

    /* Write out the name of the database and table */
    if((qn->left == NULL) && (qn->right == NULL))
    {
      /*
         If this is a join, it has 2 children, so we need to write
         the children nodes feeding the join node. Spaces are used
         to place the tables side-by-side.
      */
      if(qn->node_type == Query_tree::qntJoin)
      {
        strcpy(tblname, spacer);
        strcat(tblname, qn->relations[0]->db);
        strcat(tblname, ".");
        strcat(tblname, qn->relations[0]->table_name);
        if(strlen(tblname) < 15)
          strcat(tblname, "               ");
        else
          strcat(tblname, "          ");
        strcat(tblname, qn->relations[1]->db);
        strcat(tblname, ".");
        strcat(tblname, qn->relations[1]->table_name);
        write_printf(p, tblname, "");
        write_printf(p, spacer, "     |                              |");
        write_printf(p, spacer, "     |   ----------------------------");
        write_printf(p, spacer, "     |   |");
        write_printf(p, spacer, "     V   V");
      }
      else
              strcpy(tblname, spacer);
        strcat(tblname, qn->relations[0]->db);
        strcat(tblname, ".");
        strcat(tblname, qn->relations[0]->table_name);
        write_printf(p, tblname, "");
        write_printf(p, spacer, "     |");
        write_printf(p, spacer, "     |");
        write_printf(p, spacer, "     |");
        write_printf(p, spacer, "     V");
      }
    }
    else if((qn->left != 0) && (qn->right != 0))
    {
      write_printf(p, spacer, "     |                              |");
      write_printf(p, spacer, "     |   ----------------------------");
      write_printf(p, spacer, "     |   |");
      write_printf(p, spacer, "     V   V");
    }
    else if((qn->left != 0) && (qn->right == 0))
    {
      write_printf(p, spacer, "     |");
      write_printf(p, spacer, "     |");
      write_printf(p, spacer, "     |");
      write_printf(p, spacer, "     V");
    }
    else if(qn->right != 0)
    {
    }
    write_printf(p, spacer, "-------------------");

    /* Write out the node type */
    switch(qn->node_type)
    {
    case Query_tree::qntProject:
      {
        write_printf(p, spacer, "|     PROJECT     |");
        write_printf(p, spacer, "-------------------");
        break;
      }
    case Query_tree::qntRestrict:
      {
        write_printf(p, spacer, "|    RESTRICT     |");
        write_printf(p, spacer, "-------------------");
        break;
      }
    case Query_tree::qntJoin:
      {
        write_printf(p, spacer, "|      JOIN       |");
        write_printf(p, spacer, "-------------------");
        break;
      }
    case Query_tree::qntDistinct:
      {
        write_printf(p, spacer, "|     DISTINCT    |");
        write_printf(p, spacer, "-------------------");
        break;
      }
    default:
      {        write_printf(p, spacer, "|      UNDEF      |");
        write_printf(p, spacer, "-------------------");
        break;
      }
    }
    write_printf(p, spacer, "| Access Method:  |");
    write_printf(p, spacer, "|    iterator     |");
    write_printf(p, spacer, "-------------------");
    if(qn == root)
    {
      write_printf(p, spacer, "        |");
      write_printf(p, spacer, "        |");
      write_printf(p, spacer, "        V");
      write_printf(p, spacer, "    Result Set");
    }
  }
  my_free(spacer);
  my_free(tblname);
  DBUG_RETURN(0);
}

```

您需要做的最后一件事是添加代码来执行 DBXP `EXPLAIN`命令，调用`show_plan()`方法，并将结果返回给客户端。清单 12-26 显示了这个函数的完整代码。注意，在这个函数中，我构建了查询树，然后使用名为“执行路径”的单字符字符串列创建了一个字段列表，然后调用`show_plan`将计划写入客户端。

***[清单 12-26](#_list26) 。***DBXP 解释命令源代码

```sql
/*
  Perform EXPLAIN command.

  SYNOPSIS
    DBXP_explain_select_command()
    THD *thd            IN the current thread

  DESCRIPTION
    This method executes the EXPLAIN SELECT command.

  RETURN VALUE
    Success = 0
    Failed = 1
*/
int DBXP_explain_select_command(THD *thd)
{
  DBUG_ENTER("DBXP_explain_select_command");
  Query_tree *qt = build_query_tree(thd, thd->lex,
                                    (TABLE_LIST*) thd->lex->select_lex.table_list.first);
  List<Item> field_list;
  Protocol *protocol= thd->protocol;
  field_list.push_back(new Item_empty_string("Execution Path",NAME_LEN));
  if (protocol->send_result_set_metadata(&field_list,
                            Protocol::SEND_NUM_ROWS | Protocol::SEND_EOF))
    DBUG_RETURN(TRUE);
  protocol->prepare_for_resend();
  show_plan(protocol, qt->root, qt->root, false);
  my_eof(thd);
  DBUG_RETURN(0);
}

```

现在，让我们编译服务器并用测试文件试一试。

测试 DBXP 解释命令

与前面的测试一样，您可以使用前面章节中描述的测试，或者在 MySQL 命令行客户端中输入一个有效的 SQL 命令。清单 12-27 展示了一个查询执行路径的例子。在这一点上应该说明的是，查询没有经过优化，将显示为单个节点。一旦你添加了优化器(见[第 11 章](11.html))，查询执行路径将反映输入的查询语句的适当执行。

***[清单 12-27](#_list27) 。***DBXP 解释测试的结果

```sql
mysql> EXPLAIN DBXP_SELECT * FROM customer;

+--------------------------+
| Execution Path           |
+--------------------------+
|      test.customer       |
|           |              |
|           |              |
|           |              |
|           V              |
|      ------------------- |
|      |     PROJECT     | |
|      ------------------- |
|      | Access Method:  | |
|      |    iterator     | |
|      ------------------- |
|              |           |
|              |           |
|              V           |
|          Result Set      |
+--------------------------+
15 rows in set (0.00 sec)

mysql>
```

这比枯燥的罗列事实有趣得多。在 DBXP 项目的这个阶段添加`EXPLAIN`命令允许您观察和诊断优化器是如何形成查询树的。当你开始自己的实验时，你会发现这很有帮助。

如果到目前为止您还没有这样做，那么您应该运行完整的测试来测试本章中介绍的代码的所有三个部分。

摘要

我在本章中介绍了一些更复杂的数据库内部技术。您了解了查询是如何在 MySQL 服务器内部表示的，因为它们是通过“大开关”进行解析和处理的。更重要的是，您发现了如何使用 MySQL 通过查询树类进行自己的数据库内部实验。了解这些技术会让您更好地理解 MySQL 内部组件是如何构建的。

在下一章中，我将通过一个查询树优化策略的示例实现向您展示更多关于内部查询表示的内容。如果您想知道为关系数据库系统构建一个优化器需要什么，下一章将向您展示一个使用查询树类的启发式查询优化器的例子。

练习

下面的列表代表了您可能希望作为实验(或作为课堂作业)来探索关系数据库技术的活动类型。

1.  图 12-1 中的查询暴露了一个表格中的设计缺陷。这是什么？该缺陷是否违反了任何标准形式？如果有，是哪一个？
2.  浏览`TABLE`结构并更改`DBXP_SELECT`存根以返回关于表及其字段的信息。
3.  更改`EXPLAIN DBXP_SELECT`命令，产生类似于 MySQL `EXPLAIN SELECT`命令的输出。
4.  修改`build_query_tree`函数来识别和处理`LIMIT`子句。
5.  如何改变查询树`query_node`的结构以容纳`HAVING`、`GROUP BY`和`ORDER`子句？

奇怪的是，很少有文献对符号的选择做出解释。传统上，θ代表θ连接，![image](img/symbol.jpg)代表自然连接，但大多数文本互换了这些概念，导致所有连接都使用一个或另一个符号(有时两个都用)来表示。

[<sup>2</sup> 你能发现经常被滥用的特征吗？提示:学期属性的定义域是什么？对列中的数据进行编码违反了哪条规则？](#_Fn2)

[<sup>3</sup>](#_Fn3) 有些人会说这不应该，因为 MySQL 的内部结构是用来为优化器组织数据的。另一方面，查询树被设计为就地优化和执行。

[<sup>4</sup>](#_Fn4) 虽然许多关于查询处理主题的文章对如何区分每个过程有不同的看法，但他们都同意必须出现某些不同的过程步骤。

[<sup>5</sup>](#_Fn5) 一种被克努特和其他算法大师极力劝阻的做法。

[<sup>6</sup>](#_Fn6) 无论如何，像命令行界面那样图形化是允许的。