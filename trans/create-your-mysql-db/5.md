# 第四章数据分组

在前面的章节中，我们构建了一个数据集合，并开始通过适当的命名来清理它。我们已经在[第 1 章](2.html "Chapter 1. Introducing MySQL Design")中介绍了表的概念，它在逻辑上重组了关于某个主题的信息。在命名过程中，我们收集的一些列被分组到表中。在这样做的过程中，我们注意到名称检查的过程有时会导致我们将数据分解成更多的表，就像我们对`car_event`和`event`表所做的那样。本章的目标是通过研究将列名分组到表中的技术，为我们的结构提供最后的润色。我们的数据元素不会“在空中”；必须将它们组织成表格。这里将考虑哪些列必须放入哪个表中。

# 表格初始列表

在构建结构时，我们可以从寻找一般的、自然的主题开始，这些主题看起来很有希望对数据进行分组。这些主题将提供我们最初的表格列表，这里是该列表的一个简化示例：

*   交通工具
*   顾客
*   事件
*   汽车销售
*   顾客满意度调查

我们将通过考虑`vehicle`表开始列分组工作。

# 表格布局规则

可以有多个正确的解决方案，但任何正确的解决方案都会遵循以下原则：

*   每个表都有一个主键
*   将所有表作为一个整体考虑时，不存在冗余数据
*   表中的所有列直接依赖于主键的所有段

以下章节将详细研究这些原则。

## 主键和表名

让我们从定义**唯一键**的概念开始。定义了唯一键的列不能多次保存此表的相同值。**主键**由一列或多列组成，它是一个可用于标识表中唯一行的值。为什么我们需要主键？MySQL 本身并不强迫我们为特定表使用主键，既不是唯一键，也不是任何其他类型的键。因此 MySQL 没有义务遵守 Codd 的规则。然而，在实践中，有一个主键是很重要的；在构建 web 界面和其他应用程序时获得的经验表明，能够以独特的方式引用标识行的键是非常有用的。在 MySQL 中，主键是唯一的键，其中所有列都必须定义为`NOT NULL`；此密钥的名称为`PRIMARY`。选择主键几乎与选择表名同时进行。

选择表的名称是一个微妙的过程。我们必须具备足够的通用性，以提供未来扩展，如`vehicle`表，而不是`car`和`truck`。同时，我们尽量避免在表中出现空列。

为了决定我们应该有一个`vehicle`表还是两个单独的表，我们查看每种车辆的可能属性。它们够普遍吗？这两种车型都有颜色、型号、年份、序列号和内部 id 号。从理论上讲，列列表必须相同，以便我们确定一组列将属于单个表；但是，如果只有几个不同的属性，我们可以欺骗一点。

假设我们决定要一张`vehicle`桌子。出于前面解释的原因，我们希望跟踪车辆，因为在订购车辆时，我们将使用其内部 id 号作为主键。在设计此表时，我们会问自己，此表是否可用于存储我们从客户处收到的有关车辆的信息。答案是*是*，因为描述车辆与发生在车辆上的交易无关（新车售出，二手车从客户处购买）。第*节验证结构*给出了进一步的示例，有助于发现结构中的问题。以下是`vehicle`表的第 1 版，我们使用列名和样本值将包含主键的列标记为星号：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：车辆

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *内部识别码 | 123 |
|   | 序列号 | D8894JF |
|   | 品牌 | 利科尔内 |
|   | 模型 | 羚羊 |
|   | 年 | 2007 |
|   | 颜色 | 海洋蓝 |
|   | 条件 | 刚出现的 |

我们是否应该在此表中包括销售信息，例如价格和销售日期？我们确定答案为*否*，因为会发生很多事情：

*   这辆车可以转售
*   该表可用于保存交换中收到的车辆信息

我们现在必须审查我们的工作，并核实我们是否尊重这些原则。我们有一个主键，但是冗余和依赖性呢？

## 数据冗余和依赖

只要有可能，我们应该将冗余数据转移到查找表（也称为参考表）中，并且只将代码的值存储到主表中。我们不想在出售的每一辆独角兽的车辆表中重复“独角兽”。在进行数据库维护时，冗余数据会浪费磁盘空间并增加处理时间：如果需要修改，则必须更新相同数据的所有实例。关于`vehicle`表，在存储三个代码的`brand, model`和`color`列中存储完整的描述性值是多余的。

我们必须小心疏散冗余数据。例如，我们将不会编写年度代码；这将是太多的编码没有保存使用 A 为 2006 年，B 为 2007 年没有实际节省空间后，几千年！即使在很短的几年内，节省空间也不会很大；此外，我们还将失去计算年份的能力。

接下来，我们验证依赖关系。每列必须依赖于主键。新的/使用的状况是否直接取决于车辆？不，如果我们考虑时间维度。理论上，经销商可以出售一辆汽车，然后接受它作为交换。对于特定的日期，条件更多地与事务本身相关，因此它实际上属于此处显示的非最终状态的`sale`表。我们现在有了版本 2:

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：车辆

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *内部识别码 | 123 |
|   | 序列号 | D8894JF |
|   | 品牌代码 | L |
|   | 模型代码 | G |
|   | 年 | 2007 |
|   | 色码 | 1A6 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：品牌

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *代码 | L |
|   | 描述 | 利科尔内 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：模型

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *代码 | G |
|   | 描述 | 羚羊 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：颜色

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *代码 | 1A6 |
|   | 描述 | 海洋蓝 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：销售额

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *日期 | 2006-03-17 |
|   | *内部识别码 | 123 |
|   | 条件代码 | N |

### 组合键

**复合键**也称为复合键，是由多个列组成的键。

在布置代码表时，我们必须验证这些表上是否也遵守了数据分组原则。使用样本数据，以及我们的想象力来补充不完整的样本数据，可以帮助发现这方面的问题。在我们的版本 2 中，我们忽略了一种可能性。如果销售两个不同品牌的公司选择了相同的色码 1A6 来表示不同的颜色，该怎么办？同样的情况也可能发生在型号代码上，因此我们应该改进结构，将代表 Fontax、独角兽或未来品牌名称的品牌代码包含在`model`和`color`表中。因此，版本 3 显示了与版本 2 不同的两个表：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：模型

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *品牌代码 | L |
|   | *代码 | G |
|   | 描述 | 羚羊 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：颜色

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *品牌代码 | L |
|   | *代码 | 1A6 |
|   | 描述 | 海洋蓝 |

`model`和`color`表都会产生一个复合键。复合键的另一个示例见[第 3 章](4.html "Chapter 3. Data Naming")：`car_event`表将*数据视为列或表的名称*部分。在这类表中，主键由多个元素组成。当我们必须描述与多个表相关的数据时，就会发生这种情况。通常，新形成的包含车辆内部编号和事件代码的`car_event`表具有更多属性，如特定车辆发生特定事件的日期。

当我们遇到像公司部门这样的子集时，复合密钥的另一种可能性就会出现。仅将员工 id 与公司代码或部门代码关联将无法正确描述情况。只有在同时考虑部门和公司时，员工 id 才是唯一的。

我们必须验证此表的所有非关键数据元素是否直接依赖于整个表中的键。这里有一个有问题的例子，`company_name`列放错了位置，因为它与`dept_code:`无关

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：公司/部门

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *公司代码 | 1. |
|   | *部门代码 | 16 |
|   | 部门名称 | 营销 |
|   | 公司名称 | 丰塔克斯 |

前面的示例不是最佳的，因为公司名称将出现在用于描述每个部门的表的每一行中。上一个示例的正确结构意味着使用两个表：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：部门

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *公司代码 | 1. |
|   | *代码 | 16 |
|   | 名称 | 营销 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：公司

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *代码 | 1. |
|   | 名称 | 丰塔克斯 |

# 改善结构

即使我们的表布局尊重规则，我们仍然可以通过查看以下附加问题来改进它。

## 随时间变化的可伸缩性

在[第 3 章](4.html "Chapter 3. Data Naming")（第*节数据即结果*）中，我们可以避免为税额保留一列，前提是我们在参考表中有准确的税率。但是，这个比率可能会发生变化，因此我们需要一个包含日期范围和相应比率的更完整的表。通过这种方式，在时间维度上预测系统，我们可以确保它能够适应利率波动。注意以下`sale`表不完整：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：销售额

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *日期 | 2006-03-17 |
|   | *内部识别码 | 123 |
|   | 条件代码 | N |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：条件

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *代码 | N |
|   | 描述 | 刚出现的 |

将`sale`表中的`date`列与`tax_rate`表中的`start_date`和`end_date`列进行比较，我们可以找到销售日期的准确税率：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：税率

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *开始日期 | 2006-01-01 |
|   | *结束日期 | 2006-04-01 |
|   | 速度 | .075 |

事实上，应分析所有表格，以确定是否考虑了时间因素。另一个例子是`color`表。假设我们使用的是每个汽车制造商设计的色码，那么制造商是否会在随后的一年中重复使用不同颜色的色码？如果是这种情况，我们将在`color`表中添加一个`year`列。

## 空列

虽然空列不一定有问题，但如果某些行中有一个或多个列为空，则可能会出现结构问题：两个表折叠成一个表。让我们考虑一下汽车的运动。我们建立了一个结构，有一辆车的内部编号、事件代码和时刻。但是如果某些事件需要更多的数据来描述呢？

在纸质表格中，我们发现在洗车时，负责洗车的店员的姓名首字母会出现在表格上，在访谈中，我们了解到这些姓名首字母是一个重要的数据元素。

在这种情况下，我们可以将员工信息，即员工代码添加到`car_event`表中。这将有助于系统识别哪位店员参与了汽车发生的任何事件，从而实现更好的质量控制。

另一个可能出现的问题是，对于特定事件（比如清洗），我们需要更多的数据，如清洗产品的数量和清洗所用的时间。在这两个元素中，有一个有助于改进我们的结构：存储事件的开始和结束时间。但是在`car_event`表中添加一个类似**数量【清洁产品】**的列需要仔细分析。对于除清洗之外的所有事件，此列将保持为空，从而导致应用程序中的异常处理。如果我们再增加一个与另一个特殊事件相关的专栏，结构只会恶化。

![Empty Columns](graphics/1302_04_01.jpg)

在这种情况下，最好创建另一个具有相同键和附加列的表。我们无法避免在这个新表名`car_washing_event`中包含一些数据元素。

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：洗车活动

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *内码 | 412 |
|   | 清洁产品数量 | 12 |

## 避免枚举和设置

MySQL 和 SQL 通常提供看起来很方便的数据类型：`ENUM`和`SET`类型。这两种类型都允许我们为一列指定可能值的列表，以及一个默认值；不同之处在于`SET`列可以包含多个值，而`ENUM`列只能包含一个潜在值。

我们在这里看到一个非常小的`sale`表，`credit_rate`列是一个`ENUM:`

```
CREATE TABLE `sale` (
`internal_number` int(11) NOT NULL,
`date` date NOT NULL,
`credit_rate` ENUM('fixed','variable') NOT NULL,
PRIMARY KEY (`internal_number`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;

```

当一个字段被定义为 ENUM 或 SET，并且我们正在使用 phpMyAdmin 的插入或数据编辑面板时，会显示一个值的下拉列表，所以可能会尝试使用这些数据类型。

![Avoiding ENUM and SET](graphics/1302_04_02.jpg)

让我们来看看这些类型的好处：

*   MySQL 不存储完整的值，而是只存储一个整数索引，它使用一个或两个字节，具体取决于列表中的值的数量
*   MySQL 本身拒绝列表中未包含的任何值

即使考虑到这些好处，出于以下原因，建议不要使用`ENUM`和`SET`类型：

*   更改可能值的列表需要开发人员操作，例如结构修改干预
*   这些类型有限制：列表中有 65535 个可能值；`SET`也可以有 64 个活动成员，它们是集合中选择的值
*   最好保持系统更简单，因为在某些情况下，如果我们使用查找表，在其他情况下使用`ENUM`或`SET`类型，则程序代码的构建和维护更复杂

可以说，第一个问题可以通过在应用程序中包含一些`ALTER TABLE`语句来更改值列表来解决，但这似乎不是处理此问题的正常方式。`ALTER TABLE`是一种数据定义语句，应该在系统开发期间使用，而不是在应用程序级别使用。

因此，`ENUM`或`SET`列应该成为一个单独的表，其主键是代码。然后，引用此代码的表只是将其作为外键包含。在`SET`列的情况下，不同的表将包含主表的键加上包含这些`SET`值的表的键。

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：销售额

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *内码 | 122 |
|   | *日期 | 2006-05-27 |
|   | 信贷利率代码 | F |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：信贷利率

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | *代码 | F |
|   | 描述 | 固定的 |

应用程序中的正确验证可确保插入的代码属于查找表。

## 多语种规划

使用代码表还有另一个好处：如果我们存储新的/使用过的汽车状况，那么使用多语言应用程序会更加复杂。另一方面，如果我们对汽车的状况进行编码，那么我们可以有一个`condition`表和一个`language`表：

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：条件

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | 语言代码 | E |
|   | 条件代码 | N |
|   | 描述 | 刚出现的 |

<colgroup><col style="text-align: left"> <col style="text-align: left"> <col style="text-align: left"></colgroup> 
| 

表：语言

 | 

列名

 | 

样本值

 |
| --- | --- | --- |
|   | 语言代码 | E |
|   | 描述 | 英语 |

# 验证结构

验证是通过使用精确的例子来完成的，询问我们自己是否有一个列来放置所有信息，涵盖所有案例。也许会有例外，该怎么办？我们的结构应该处理这些问题吗？我们可以评估与这些异常相关的风险因素，以及处理这些异常的成本和查询性能的可能损失。

例外情况的一个示例：客户在同一天购买两辆车这可能会影响主键的选择，如果日期是此键的一部分，则有助于在此键上添加一列：销售的时间。

phpMyAdmin 实用程序在这里可以证明是有用的。使用该软件可以轻松地构建表，而其索引管理功能允许我们制作主键。然后，我们可以使用多表查询生成器来模拟各种报告和 ifs。

# 总结

我们已经看到，我们的列列表需要放在适当的表中，每个表都有一个主键，并遵守一些规则以提高效率和清晰度。我们还可以通过研究可伸缩性和多语言问题来改进模型；然后我们学习了一种验证这个模型的方法。