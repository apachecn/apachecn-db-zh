# 附录

# 1。MongoDB 简介

## 活动 1.01：建立电影数据库

**溶液：**

以下步骤将帮助您完成此活动：

1.  首先，连接到作为*练习 1.04**在 Atlas*上设置第一个免费 MongoDB 集群的一部分而设置的 MongoDB 集群。应该是这样的：

    ```
    mongo "mongodb+srv://cluster0-zlury.mongodb.net/test" –username   <yourUsername>
    ```

2.  在命令提示符下输入前面的命令，并在提示时提供密码。成功登录后，您将看到一个带有集群名称的 shell 提示，类似于：

    ```
    MongoDB Enterprise Cluster0-shard-0:PRIMARY>
    ```

3.  现在，创建电影数据库并将其命名为**moviesDB**。使用**使用**命令：

    ```
    use moviesDB
    ```

4.  Create the **movies** collection with a few relevant attributes. Create the collection by inserting the documents into a non-existent collection. You are encouraged to think and implement collections with attributes that you find most suitable:

    ```
    db.movies.insertMany(
        [
            {
                "title": "Rocky",
                "releaseDate": new Date("Dec 3, 1976"),
                "genre": "Action",
                "about": "A small-time boxer gets a supremely rare               chance to fight a heavy-weight champion in a bout                 in which he strives to go the distance for his                   self-respect.",
                "countries": ["USA"],
                "cast" : ["Sylvester Stallone","Talia Shire",              "Burt Young"],
                "writers" : ["Sylvester Stallone"],
                "directors" : ["John G. Avildsen"]
            },
            {
                "title": "Rambo 4",
                "releaseDate ": new Date("Jan 25, 2008"),
                "genre": "Action",
                "about": "In Thailand, John Rambo joins a group of               mercenaries to venture into war-torn Burma, and rescue                 a group of Christian aid workers who were kidnapped                   by the ruthless local infantry unit.",
                "countries": ["USA"],
                "cast" : [" Sylvester Stallone", "Julie Benz", "Matthew               Marsden"],
                "writers" : ["Art Monterastelli","Sylvester Stallone"],
                "directors" : ["Sylvester Stallone"]
            }
        ]
    )
    ```

    这将产生以下输出：

    ```
    {
      "acknowledged" : true,
      "insertedIds" : [
        ObjectId("5f33d027592962df72246aed"),
        ObjectId("5f33d027592962df72246aee")
      ]
    }
    ```

5.  使用**find**命令获取上一步插入的文档，即**db.movies.find（）.pretty（）**。它应该返回以下输出：

    ```
    {
          "_id" : ObjectId("5f33d027592962df72246aed"),
          "title" : "Rocky",
          "releaseDate" : ISODate("1976-12-02T13:00:00Z"),
          "genre" : "Action",
          "about" : "A small-time boxer gets a supremely rare chance to         fight a heavy-weight champion in a bout in which he strives to           go the distance for his self-respect.",
          "countries" : [
                "USA"
          ],
          "cast" : [
                "Sylvester Stallone",
                "Talia Shire",
                "Burt Young"
          ],
          "writers" : [
                "Sylvester Stallone"
          ],
          "directors" : [
                "John G. Avildsen"
          ]
    }
    {
          "_id" : ObjectId("5f33d027592962df72246aee"),
          "title" : "Rambo 4",
          "releaseDate " : ISODate("2008-01-24T13:00:00Z"),
          "genre" : "Action",
          "about" : "In Thailand, John Rambo joins a group of mercenaries         to venture into war-torn Burma, and rescue a group of           Christian aid workers who were kidnapped by the ruthless             local infantry unit.",
          "countries" : [
                "USA"
          ],
          "cast" : [
                " Sylvester Stallone",
                "Julie Benz",
                "Matthew Marsden"
          ],
          "writers" : [
                "Art Monterastelli",
                "Sylvester Stallone"
          ],
          "directors" : [
                "Sylvester Stallone"
          ]
    }
    {
          "_id" : ObjectId("5f33d050592962df72246aef"),
          "title" : "Rocky",
          "releaseDate" : ISODate("1976-12-02T13:00:00Z"),
          "genre" : "Action",
          "about" : "A small-time boxer gets a supremely rare chance to         fight a heavy-weight champion in a bout in which he strives to           go the
              distance for his self-respect.",
          "countries" : [
                "USA"
          ],
          "cast" : [
                "Sylvester Stallone",
                "Talia Shire",
                "Burt Young"
          ],
          "writers" : [
                "Sylvester Stallone"
          ],
          "directors" : [
                "John G. Avildsen"
          ]
    }
    {
          "_id" : ObjectId("5f33d050592962df72246af0"),
          "title" : "Rambo 4",
          "releaseDate " : ISODate("2008-01-24T13:00:00Z"),
          "genre" : "Action",
          "about" : "In Thailand, John Rambo joins a group of mercenaries         to venture into war-torn Burma, and rescue a group of           Christian aid
              workers who were kidnapped by the ruthless local             infantry unit.",
          "countries" : [
                "USA"
          ],
          "cast" : [
                " Sylvester Stallone",
                "Julie Benz",
                "Matthew Marsden"
          ],
          "writers" : [
                "Art Monterastelli",
                "Sylvester Stallone"
          ],
          "directors" : [
                "Sylvester Stallone"
          ]
    }
    ```

6.  You may also like to store awards information in your movies database. Create an **awards** collection with a few records. You are encouraged to think and come up with your own collection name and attributes. Here are the commands to insert a few sample documents in your **awards** collection:

    ```
    db.awards.insertOne(
        {
            "title": "Oscars",
            "year": "1976",
            "category": "Best Film",
            "nominees": ["Rocky","All The President's Men","Bound For           Glory","Network","Taxi Driver"],
            "winners" :
            [
                {
                    "movie" : "Rocky"
                }
            ]
        }
    )
    db.awards.insertOne(
        {
            "title": "Oscars",
            "year": "1976",
            "category": "Actor In A Leading Role",
            "nominees": ["PETER FINCH","ROBERT DE NIRO","GIANCARLO           GIANNINI"," WILLIAM HOLDEN","SYLVESTER STALLONE"],
            "winners" :
            [
                {
                    "actor" : "PETER FINCH",
                    "movie" : "Network"
                }
            ]
        }
    )
    ```

    每个命令都应生成如下输出：

    ```
    {
          "acknowledged" : true,
          "insertedId" : ObjectId("5f33d08e592962df72246af1")
    }
    ```

    每个命令都应生成如下输出：

    ```
    {
      "acknowledged" : true,
      "insertedId" : ObjectId("5f33d08e592962df72246af1")
    }
    ```

    笔记

    插入的 ID 是插入的文档的唯一 ID，因此它与前面输出中提到的不同。

7.  Run the **find** command to get the documents from the **awards** collection. The lines starting with **//** (a double slash) are comments, which are only for the purpose of description; the database does not execute them as commands:

    ```
    // find all the documents from the awards collection
    db.awards.find().pretty()
    ```

    以下是前面命令的输出：

    ![Figure 1.39: Documents from the awards collection ](image/B15507_01_39.jpg)

图 1.39：奖项收集的文件

笔记

本练习旨在为您添加您认为有效存储电影数据所需的尽可能多的集合/文档。请随意添加更多相关的收藏和文档。

在本活动中，您找到了电影数据库的相关数据库解决方案。您还在 MongoDB Atlas 上创建了一个数据库，用于存储收藏和文档。

在下一章中，将向您提供导入另一个关于电影的示例数据集的步骤。建议您现实地考虑电影数据库需要哪些其他集合或集合中的属性。在下一章中，您还将看到您的数据集与提供的示例有何不同。

# 2。文件和数据类型

## 活动 2.01：将 Tweet 建模为 JSON 文档

**溶液：**

执行以下步骤以完成活动：

1.  识别并列出推文中可包含在 JSON 文档中的以下字段：

    ```
    creation date and time
    user id
    user name 
    user profile pic
    user verification status
    hash tags
    mentions
    tweet text
    likes
    comments
    retweets
    ```

2.  对相关字段进行分组，以便它们可以作为嵌入对象或数组放置。因为 tweet 可以有多个 hashtag 和提及，所以它可以表示为一个数组。修改后的列表显示如下：

    ```
    creation date and time
    user 
      id
      name 
      profile pic
      verification status
    hash tags
      [tags]
    mentions
      [mentions]
    tweet text
    likes
    comments
    retweets
    ```

3.  准备用户对象并添加推文中的值：

    ```
    {
      "id": "Lord_Of_Winterfell",
      "name": "Office of Ned Stark",
      "profile_pic": "https://user.profile.pic",
      "isVerified": true
    }
    ```

4.  将所有 hashtag 列为一个数组：

    ```
    [
      "north",
      "WinterfellCares",
      "flueshots"
    ]
    ```

5.  Include all the mentions as an array:

    ```
    [
      "MaesterLuwin",
      "TheNedStark",
      "CatelynTheCat"
    ]
    ```

    将所有文档与其余字段合并后，最终输出将如下所示：

    ```
    {
      "id": 1,
      "created_at": "Sun Apr 17 16:29:24 +0000 2011",
      "user": {
        "id": "Lord_Of_Winterfell",
        "name": "Office of Ned Stark",
        "profile_pic": "https://user.profile.pic",
        "isVerified": true
      },
      "text": "Tweeps in the #north. The long nights are upon us. Do            stock enough warm clothes, meat and mead…",
      "hashtags": [
        "north",
        "WinterfellCares",
        "flueshots"
      ],
      "mentions": [
        "MaesterLuwin",
        "TheNedStark",
        "CatelynTheCat"
      ],
      "likes_count": 14925,
      "retweet_count": 12165,
      "comments_count": 0
    }
    ```

6.  Click on **Validate JSON** to validate the code from any text editor as follows:

    ![Figure 2.21: Validated JSON document ](image/B15507_02_21.jpg)

图 2.21：已验证的 JSON 文档

在本活动中，您将推特中的数据建模为有效的 JSON 文档。

# 3。服务器和客户端

## 活动 3.01：管理您的数据库用户

**溶液：**

以下是活动的详细步骤：

1.  转到[http://cloud.mongodb.com](14.html) 连接到 Atlas 控制台。
2.  Log on to your new MongoDB Atlas web interface using your username and password, which was created when you registered for the Atlas Cloud:

    ![Figure 3.40: MongoDB Atlas login page  ](image/B15507_03_40.jpg)

    图 3.40:MongoDB Atlas 登录页面

3.  Create a new database called **dev_mflix** and, on the Atlas clusters page, click the **COLLECTIONS** button:

    ![Figure 3.41: MongoDB Atlas Clusters Page  ](image/B15507_03_41.jpg)

    图 3.41:MongoDB Atlas 集群页面

    此时会出现一个包含所有集合的窗口，如*图 3.42*所示：

    ![Figure 3.42: MongoDB Atlas data explorer ](image/B15507_03_42.jpg)

    图 3.42:MongoDB Atlas 数据浏览器

4.  Next, click the **+Create Database** button, at the top of the database list. The following window will appear:

    ![Figure 3.43: MongoDB Create Database window ](image/B15507_03_43.jpg)

    图 3.43:MongoDB 创建数据库窗口

5.  将**数据库名称**设置为**dev_mflix**，将**集合名称**设置为**dev_data01**，然后点击**创建**按钮。
6.  创建一个名为**开发者**的自定义角色。点击**数据库访问**（左侧）。在**数据库访问**页面，点击**自定义角色**选项卡。
7.  Click on the **Add Custom Role** button. The **Add Custom Role** window will appear, as in the following screenshot:

    ![Figure 3.44: The Add Custom Role window ](image/B15507_03_44.jpg)

    图 3.44：添加自定义角色窗口

8.  Within new **Developers** role, add the **readWrite** role on **dev_mflix** database. Then, add the **read** role on **sample_mflix** database and click on the **Add Custom Role** button. The new **Developers** role will appear in the list:

    ![Figure 3.45: Database Access – Custom Roles ](image/B15507_03_45.jpg)

    图 3.45：数据库访问-自定义角色

9.  Create the new Atlas user, **Mark**. In the **Database Access** menu, click the **+Add New Database User** button. The **Add New Database User** window will appear as follows:

    ![Figure 3.46: Adding a new user called Mark ](image/B15507_03_46.jpg)

    图 3.46：添加名为 Mark 的新用户

10.  Fill in the details as follows:

    用户名：**标记**

    认证方式：**紧急停堆**

    预定义自定义角色：**开发者**

    现在，Atlas 用户列表中应该出现一个名为**Mark**的新用户：

    ![Figure 3.47: Atlas database users ](image/B15507_03_47.jpg)

    图 3.47：Atlas 数据库用户

11.  Connect to the MongoDB cloud database as user **Mark** and run the **db.getUser()** shell function. The expected shell output is shown in the following screenshot:

    ![Figure 3.48: Shell output (example) ](image/B15507_03_48.jpg)

图 3.48：外壳输出（示例）

活动到此结束。Atlas 系统中添加了一个名为 Mark 的新开发人员，并授予了相应的访问权限。

# 4。查询文档

## 活动 4.01：按类型和分页结果查找电影

**溶液：**

**FindMoviesByGene**函数最重要的部分是底层 MongoDB 查询。您将采取逐步解决问题的方法，首先在 mongo shell 上创建查询。准备好查询后，将其包装到函数中：

1.  创建查询以按**类型**筛选结果。对于本次活动，我们使用的是**动作**体裁：

    ```
          db.movies.find(
              {"genres" : "Action"}
          )
    ```

2.  要求只返回电影的标题。为此，添加一个投影，仅投影**标题**字段，并排除其余字段，包括**\u id**：

    ```
          db.movies.find(
              {"genres" : "Action"},
              {"_id" : 0, "title" :1}
          )
    ```

3.  现在，按 IMDb 评级的降序对结果进行排序。在查询中添加一个**sort（）**函数：

    ```
          db.movies.find(
              {"genres" : "Action"},
              {"_id" : 0, "title" :1})
          .sort({"imdb.rating" : -1})
    ```

4.  添加**跳过**功能，现在提供您想要的任何值（**3**，在本例中）：

    ```
          db.movies.find(
              {"genres" : "Action"}, 
              {"_id" : 0, "title" :1})
         .sort({"imdb.rating" : -1})
         .skip(3)
    ```

5.  接下来，在查询中添加一个**限制**，如下所示。限制值表示页面大小：

    ```
          db.movies.find(
              {"genres" : "Action"}, 
              {"_id" : 0, "title" :1})
         .sort({"imdb.rating" : -1})
         .skip(3)
         .limit(5)
    ```

6.  最后，使用**toArray（）**函数

    ```
         db.movies.find(
             {"genres" : "Action"}, 
             {"_id" : 0, "title" :1})
         .sort({"imdb.rating" : -1})
         .skip(3)
         .limit(5)
         .toArray()
    ```

    将结果游标转换为数组
7.  现在已经编写好查询，打开一个文本编辑器并编写一个空函数，该函数接受类型、页码和页面大小，如下所示：

    ```
          var findMoviesByGenre = function(genre, pageNumber, pageSize){
          }
    ```

8.  在函数中复制并粘贴查询，并将其分配给变量，如下所示：

    ```
          var findMoviesByGenre = function(genre, pageNumber, pageSize){
              var movies = db.movies.find(
                  {"genres" : "Action"}, 
                  {"_id" : 0, "title" :1})
              .sort({"imdb.rating" : -1})
              .skip(3)
              .limit(5)
              .toArray()
          }
    ```

9.  您将得到一个数组。编写遍历元素所需的逻辑，并打印**标题**字段，如下所示：

    ```
          var findMoviesByGenre = function(genre, pageNumber, pageSize){
              var movies = db.movies.find(
                  {"genres" : "Action"}, 
                  {"_id" : 0, "title" :1})
              .sort({"imdb.rating" : -1})
              .skip(3)
              .limit(5)
              .toArray()
              print("************* Page : " + pageNumber)
              for(var i =0; i < movies.length; i++){
                  print(movies[i].title)
              }
          }
    ```

10.  查询仍然有硬编码的值需要替换为作为函数参数接收的变量，因此将**类型**和**页面大小**变量放在正确的位置：

    ```
          var findMoviesByGenre = function(genre, pageNumber, pageSize){

              var movies = db.movies.find(
                  {"genres" : genre}, 
                  {"_id" : 0, "title" :1})
              .sort({"imdb.rating" : -1})
              .skip(3)
              .limit(pageSize)
              .toArray()
              print("************* Page : " + pageNumber)
              for(var i =0; i < movies.length; i++){
                  print(movies[i].title)
              }
          }
    ```

11.  Now, you need to derive the skip value based on the page number and page size. When the user is on the first page, the skip value should be zero. On the second page, the skip value should be the page size. Similarly, if the user is on the third page, the skip value should be page size multiplied by 2\. Write this logic as follows:

    ```
          var findMoviesByGenre = function(genre, pageNumber, pageSize){
              var toSkip = 0;
              if(pageNumber < 2){
                  toSkip = 0;
              } else{
                  toSkip = (pageNumber -1) * pageSize;
              }
              var movies = db.movies.find(
                  {"genres" : genre}, 
                  {"_id" : 0, "title" :1})
              .sort({"imdb.rating" : -1})
              .skip(toSkip)
              .limit(pageSize)
              .toArray()
              print("************* Page : " + pageNumber)
              for(var i =0; i < movies.length; i++){
                  print(movies[i].title)
              }
    }
    ```

    现在，在 limit 函数中使用新计算的 skip 值。这使得功能完整。

12.  将函数复制并粘贴到 mongo shell 中并执行它。您应该看到以下结果：

![Figure 4.46: Final output ](image/B15507_04_46.jpg)

图 4.46：最终产出

在本次活动中，通过使用**排序（）**、**跳过（）**和**限制（）**功能，您为您的电影服务实现了分页，极大地改善了用户体验。

# 5。插入、更新和删除文档

## 活动 5.01：更新电影评论

**溶液：**

执行以下步骤以完成活动：

1.  First, update the **movie_id** field in all three comments. As we need to apply the same update to all three comments, we will use the **findOneAndUpdate()** function along with the **$set** operator to change the value of the field:

    ```
    db.comments.updateMany(
      {
        "_id" : {$in : [
          ObjectId("5a9427658b0beebeb6975eb3"),
          ObjectId("5a9427658b0beebeb6975eb4"),
          ObjectId("5a9427658b0beebeb6975eaa")
        ]}
      },
      {
        $set : {"movie_id" : ObjectId("573a13abf29313caabd25582")}
      }
    )
    ```

    使用 update 命令，我们通过他们的**id**查找三部电影，并使用操作符中的**$提供他们的主键。然后，我们使用**$set**更新字段**movie_id**的值。**

2.  Connect to the MongoDB Atlas cluster, use the database **sample_mflix**, and then execute the command in the previous step. The output should be as follows:

    ![Figure 5.30: Assigning the correct movie to the comments ](image/B15507_05_30.jpg)

    图 5.30：为评论分配正确的电影

    输出确认所有三条注释都已正确更新。

3.  Find the movie **Sherlock Holmes** by **_id** and reduce the count of comments by **3**:

    ```
    db.movies.findOneAndUpdate(
      {"_id" : ObjectId("573a13bcf29313caabd57db6")},
      {$inc : {"num_mflix_comments" : -3}},
      {
        "returnNewDocument" : true,
        "projection" : {"title" : 1, "num_mflix_comments" : 1}
      }
    )
    ```

    这里的更新命令通过**id**查找电影，并使用带有负数的**$inc**将**num_mflix_comments**计数减少 3。它返回包含字段**title**和**num_mflix_comments**的修改文档。

4.  Execute the command on the same mongo shell, as follows:

    ![Figure 5.31: Incrementing the count of comments on Sherlock Holmes ](image/B15507_05_31.jpg)

    图 5.31：增加对福尔摩斯的评论数量

    输出显示注释数量正确减少了**3**。

5.  Finally, prepare a similar command on **50 First Dates** and increase the number of comments by **3**. The following command should be used for this:

    ```
    db.movies.findOneAndUpdate(
      {"_id" : ObjectId("573a13abf29313caabd25582")},
      {$inc : {"num_mflix_comments" : 3}},
      {
        "returnNewDocument" : true,
        "projection" : {"title" : 1, "num_mflix_comments" : 1}
      }
    )
    ```

    在这个更新操作中，我们通过电影的**id**来查找电影，并使用**$inc**的正值 3 来增加评论数量。它还返回更新后的文档，并仅返回字段**title**和**num_mflix_comments**。

6.  Now, execute the command on the mongo shell:

    ![Figure 5.32: Decrementing the count of comments on 50 First Dates ](image/B15507_05_32.jpg)

图 5.32：减少 50 个第一天的评论数量

输出显示注释的数量已正确增加。在本活动中，我们练习了在更新操作期间修改不同集合的字段以及递增和递减数值字段的值。

# 6。使用聚合管道和阵列进行更新

## 活动 6.01：在演员阵容中添加演员姓名

**溶液：**

执行以下步骤以完成活动：

1.  Since only one movie document must be updated, use the **findOneAndUpdate()** command. Open a text editor and type the following command:

    ```
          db.movies.findOneAndUpdate({"title" : "Jurassic World"})
    ```

    此查询使用基于电影标题的查询表达式。

2.  Prepare an update expression to insert an element into the array. As the cast array must be unique, use **$addToSet**, as follows:

    ```
        db.movies.findOneAndUpdate(
            {"title" : "Jurassic World"},
            {$addToSet : {"cast" : "Nick Robinson"}}
        )
    ```

    此查询将**Nick Robinson**插入**演员阵容**中，并确保没有插入重复的。

3.  Next, you need to sort the array. Since sets are unordered collections, you cannot use **$sort** in an **$addToSet** expression. Instead, first add the element to the set and then sort it. Open the mongo shell and connect to the **sample_mflix** database:

    ```
        db.movies.findOneAndUpdate(
            {"title" : "Jurassic World"},
            {$addToSet : {"cast" : "Nick Robinson"}},
            {
                "returnNewDocument" : true,
                "projection" : {"_id" : 0, "title" : 1, "cast" : 1}
            }
        )
    ```

    在此命令中，**returnNewDocument**标志已设置为**true**，并且仅投影了**标题**和**演员**字段。在**样本**数据库中执行查询：

    ![Figure 6.23: Adding the missing cast member's name ](image/B15507_06_23.jpg)

    图 6.23：添加缺少的演员姓名

    屏幕截图确认元素**Nick Robinson**已正确添加到数组末尾。

4.  打开一个文本编辑器，编写一个基本的更新命令，并使用相同的查询表达式：

    ```
    db.movies.findOneAndUpdate(
        {"title" : "Jurassic World"}
    )
    ```

5.  Modify the command, add a **$push** expression to the array, and provide the **$sort** option:

    ```
        db.movies.findOneAndUpdate(
            {"title" : "Jurassic World"},
            {$push : {
                "cast" : {
                    $each : [],
                    $sort : 1
                }}
            }
        )
    ```

    由于不需要推送新元素，一个空数组已传递给**$each**操作符。

6.  添加**returnNewDocument**标志，将投影添加到**标题**和**演员**字段，并执行命令，如下所示：

    ```
        db.movies.findOneAndUpdate(
            {"title" : "Jurassic World"},
            {$push : {
                "cast" : {
                    $each : [],
                    $sort : 1
                }}
            },
            {
                "returnNewDocument" : true,
                "projection" : {"_id" : 0, "title" : 1, "cast" : 1}
            }
        )
    ```

7.  Open the mongo shell, connect to the **sample_mflix** database, and execute the command:

    ![Figure 6.24: Sorting the missing cast ](image/B15507_06_24.jpg)

图 6.24：对丢失的铸件进行排序

输出确认**cast**数组现在按元素的升序按字母顺序排序。

# 7。数据聚合

## 活动 7.01：将聚合付诸实践

**溶液：**

执行以下步骤以完成活动：

1.  首先，创建脚手架代码：

    ```
    // Chapter_7_Activity.js
    var chapter7Activity = function() {
        var pipeline = [];
        db.movies.aggregate(pipeline).forEach(printjson);
    }
    Chapter7Activity()
    ```

2.  为早于 2001 年的文档添加第一个匹配项：

    ```
    var pipeline = [
        {$match: {
            released: {$lte: new ISODate("2001-01-01T00:00:00Z")}
        }}
      ];
    ```

3.  为至少有一次获奖的电影添加第二个比赛条件：

    ```
        {$match: {
            released: {$lte: new ISODate("2001-01-01T00:00:00Z")},
            "awards.wins": {$gte: 1},
        }}
    ```

4.  为奖项提名添加**排序**条件。这是为了确保我们的**$group**声明中的**$first**运营商为每种类型获得最高提名电影：

    ```
            {$sort: {
                "awards.nominations": -1
            }},
    ```

5.  Add the **$group** stage. Create groups based on the first genre and output the **$first** film in each group, along with the sum of award wins for that genre:

    ```
            { $group: {
                _id: {"$arrayElemAt": ["$genres", 0]},
                "film_id": {$first: "$_id"},
                "film_title": {$first: "$title"},
                "film_awards": {$first: "$awards"},
                "film_runtime": {$first: "$runtime"},
                "genre_award_wins": {$sum: "$awards.wins"},
              }},
    ```

    在**评论**集合上执行联接，以检索每组中的电影评论。这将把我们计算的**电影 id**字段与**电影 id**注释字段连接起来。将此新阵列称为**注释**：

    ```
              { $lookup: {
                from: "comments",
                localField: "film_id",
                foreignField: "movie_id",
                as: "comments"
            }},
    ```

6.  仅投影新数组中的第一条注释，以及要在末尾输出的任何字段。使用**$slice**操作符仅返回**注释**数组中的第一个条目。还记得将预告片添加到电影运行时：

    ```
            { $project: {
                film_id: 1,
                film_title: 1,
                film_awards: 1,
                film_runtime: { $add: [ "$film_runtime", 12]},
                genre_award_wins: 1,
                  "comments": { $slice: ["$comments", 1]}
              }}, 
    ```

7.  Finally, sort by **genre_award_wins** and limit to three documents:

    ```
              { $sort: {
                  "genre_award_wins": -1}},
              { $limit: 3}
    ```

    您的最终管道现在应该如下所示：

    ```
    var chapter7Activity = function() {
        var pipeline = [
            {$match: {
                released: {$lte: new ISODate("2001-01-01T00:00:00Z")},
                "awards.wins": {$gte: 1},
            }},
            {$sort: {
                "awards.nominations": -1}},
            { $group: {
                _id: {"$arrayElemAt": ["$genres", 0]},
                "film_id": {$first: "$_id"},
                "film_title": {$first: "$title"},
                "film_awards": {$first: "$awards"},
                "film_runtime": {$first: "$runtime"},
                "genre_award_wins": {$sum: "$awards.wins"},
              }},
              { $lookup: {
                from: "comments",
                localField: "film_id",
                foreignField: "movie_id",
                as: "comments"}},
            { $project: {
                film_id: 1,
                film_title: 1,
                film_awards: 1,
                film_runtime: { $add: [ "$film_runtime", 12]},
                genre_award_wins: 1,
                  "comments": { $slice: ["$comments", 1]}
              }}, 
              { $sort: {
                  "genre_award_wins": -1
              }},
              { $limit: 3}
        ];
        db.movies.aggregate(pipeline).forEach(printjson);
    }
    Chapter7Activity();
    ```

    您的输出将如下所示：

    ![Figure 7.24: Final output after running the pipeline (truncated for brevity) ](image/B15507_07_24.jpg)

图 7.24：运行管道后的最终输出（为简洁起见截断）

在本活动中，我们整合了聚合管道的所有不同方面，以跨集合查询、转换和连接数据。通过结合本章中学习的方法，您现在将能够自信地设计和编写有效的聚合管道，以解决复杂的业务问题。

# 8。在 MongoDB 中编写 JavaScript

## 活动 8.01：创建一个简单的 Node.js 应用程序

**溶液：**

执行以下步骤以完成活动：

1.  导入**读线**和 MongoDB 库：

    ```
    const readline = require('readline');
    const MongoClient = require('mongodb').MongoClient;
    ```

2.  创建您的**读线**界面：

    ```
    const interface = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    ```

3.  声明您需要的任何变量：

    ```
    const url = 'mongodb+srv://mike:password@myAtlas-  fawxo.gcp.mongodb.net/test?retryWrites=true&w=majority';
    const client = new MongoClient(url);
    const databaseName = "sample_mflix";
    const collectionName = "movies";
    ```

4.  创建一个名为**列表**的函数，该函数将获取给定类型的前五名电影，返回它们的**标题**、**收藏夹**和**ID**字段。*您需要在此函数中请求类别。查看练习 7.05**中的***登录***方法*处理 Node.js 中的输入，了解更多信息。结合前面练习中的***查找***代码*：

    ```
    const list = function(database, client) {
        interface.question("Please enter a category: ", (category) => {
            database.collection(collectionName).find({genres: { $all: [category]          }}).limit(5).project({title: 1, favourite:             1}).toArray(function(err, docs) {
                if(err) {
                    console.log('Error in query.');
                    console.log(err);
                }
                else if(docs) {
                    console.log('Docs Array');
                    console.log(docs);
                } else {
                }
                prompt(database, client);
                return;
             });
          });
    }
    ```* 
5.  创建一个名为**收藏夹**的函数，该函数将按标题更新文档，并向文档中添加一个名为**收藏夹**的键，该键的值为**true**。您需要使用与您的**列表**函数相同的方法在此函数中请求标题。结合前面练习中更新的代码：

    ```
    const favourite = function(database, client) {
        interface.question("Please enter a movie title: ", (newTitle) => {
            database.collection(collectionName).updateOne({title: newTitle},           {$set: {favourite: true}}, function(err, result) {
                if(err) {
                    console.log('Error updating');
                    console.log(err);
                    return false;
                }
                console.log('Updated documents #:');
                console.log(result.modifiedCount);
                prompt(database, client);
            })
        })
    }
    ```

6.  根据用户的输入创建一个交互式的**while**循环。如果您不确定如何执行此操作，请参考*练习 8.05*中的**提示**功能，*处理 Node.js*中的输入：

    ```
    const prompt = function(database, client) {
        interface.question("list, favourite OR exit: ", (input) => {
            if(input === "exit") {
                client.close();
                return interface.close(); // Will kill the loop.
            }   
            else if(input === "list") {
                list(database, client);
            }
            else if(input === "favourite") {
                favourite(database, client);
            }
            else { // If input matches none of our options.
                prompt(database, client)
            }
          });
    }
    ```

7.  Create the MongoDB connection and database, calling your **prompt** function if the database creates successfully:

    ```
    client.connect(function(err) {
        if(err) {
            console.log('Failed to connect.');
            console.log(err);
            return false;
        }
        // Within the connection block, add a console.log to confirm the       connection
        console.log('Connected to MongoDB with NodeJS!');
        const database = client.db(databaseName);
        if(!database) {
            console.log('Database object doesn't exist!');
            return false;
        } else {
            prompt(database, client);
        }
    })
    ```

    请记住，您需要将**数据库**和**客户端**对象传递给每个函数，包括调用**提示符**函数的任何时候。

8.  Run your code using **node Activity8.01.js**.

    ![Figure 8.9: Final output (truncated for brevity)  ](image/B15507_08_09.jpg)

图 8.9：最终输出（为简洁起见截断）

在本活动中，您创建了一个具有交互式输入循环的应用程序，并实现了错误处理以处理用户输入的无效输入类型。

# 9。表演

## 活动 9.01：优化查询

**溶液：**

执行以下步骤以完成活动：

1.  打开 mongo 外壳，连接 Atlas 集群上的**样本**数据库。首先，您需要找到查询返回的记录数。下面的片段显示了一个**计数**查询，它给出了丹佛商店出售的背包数量：

    ```
         db.sales.count(
             {
                 "items.name" : "backpack",
                 "storeLocation" : "Denver"
             }
         )

    ```

2.  查询返回**711**条记录的计数。
3.  Next, analyze the query given by the analytics team using the **explain()** function, and print the execution stats, as follows:

    ```
    db.sales.find(
             {
                 "items.name" : "backpack",
                 "storeLocation" : "Denver"
             },
             {
                 "_id" : 0,
                 "customer.email": 1,
                 "customer.age": 1
             }
         ).sort({
             "customer.age" : -1
         }).explain("executionStats")
    ```

    查询通过将**executionStats**作为参数传递来调用**explain（）**函数。下面的代码片段显示了输出的**executionStats**部分：

    ```
    "executionStats" : {
        "executionSuccess" : true,
        "nReturned" : 711,
        "executionTimeMillis" : 10,
        "totalKeysExamined" : 0,
        "totalDocsExamined" : 5000,
        executionStages" : {
            "stage" : "PROJECTION_DEFAULT",
            "nReturned" : 711,
            "executionTimeMillisEstimate" : 1,
            "works" : 5715,
            "advanced" : 711,
            "needTime" : 5003,
            "needYield" : 0,
            "saveState" : 44,
            "restoreState" : 44,
            "isEOF" : 1,
            "transformBy" : {
                "_id" : 0,
                "customer.email" : 1,
                "customer.age" : 1
            },
            "inputStage" : {
                "stage" : "SORT",
                "nReturned" : 711,
                "executionTimeMillisEstimate" : 1,
                "works" : 5715,
                "advanced" : 711,
                "needTime" : 5003,
                "needYield" : 0,
                "saveState" : 44,
                "restoreState" : 44,
                "isEOF" : 1,
                "sortPattern" : {
                    "customer.age" : -1
                },
                "memUsage" : 745392,
                "memLimit" : 33554432,
                "inputStage" : {
                    "stage" : "SORT_KEY_GENERATOR",
                    "nReturned" : 711,
                        "executionTimeMillisEstimate" : 1,
                        "works" : 5003,
                        "advanced" : 711,
                        "needTime" : 4291,
                        "needYield" : 0,
                        "saveState" : 44,
                        "restoreState" : 44,
                        "isEOF" : 1,
                        "inputStage" : {
                            "stage" : "COLLSCAN",
                            "filter" : {
                                "$and" : [
                                    {
                                        "items.name" : {
                                                "$eq" : "backpack"
                                            }
                                    },
                                    {
                                            "storeLocation" : {
                                                "$eq" : "Denver"
                                            }
                                    }
                                ]
                            },
                            "nReturned" : 711,
                            "executionTimeMillisEstimate" : 1,
                            "works" : 5002,
                            "advanced" : 711,
                            "needTime" : 4290,
                            "needYield" : 0,
                            "saveState" : 44,
                            "restoreState" : 44,
                            "isEOF" : 1,
                            "direction" : "forward",
                            "docsExamined" : 5000
                             }
                }
            }
        }
    },
    ```

    输出表明要返回**711**记录，所有**5000**记录都被扫描。它还表示执行是从**COLLSCAN**阶段开始的，这意味着最初没有索引来支持查询中的字段。

    要提高查询性能，可以在集合上创建索引。由于查询在筛选条件中使用两个字段，因此请在索引中同时使用这两个字段。但是，查询也有一个排序规范，如 executionstat 所示，排序是在内存中执行的。要避免内存扫描，请在索引中包含排序字段。

4.  Create a compound index on the collection and include **items.name**, **storeLocation**, and **customer.age** fields. The following query creates a compound index on the **sales** collection:

    ```
    db.sales.createIndex(
        {
            "items.name" : 1,
            "storeLocation" : 1,
            "customer.age" : -1
        }
    )
    ```

    输出表明已正确创建索引，如下所示：

    ```
    {
        "createdCollectionAutomatically" : false,
             "numIndexesBefore" : 1,
             "numIndexesAfter" : 2,
             "ok" : 1,
             "$clusterTime" : {
                 "clusterTime" : Timestamp(1603246555, 1),
            "signature" : {
                "hash" : BinData(0,"yLQFK4QAJ0ci0M0PzZTex+K73LU="),
                "keyId" : NumberLong("6827475821280624642")
            }
        },
             "operationTime" : Timestamp(1603246555, 1)
    }
    ```

    再次执行*步骤 2*中执行的**explain（）**查询。下面的代码片段显示了输出的**executionStats**部分：

    ```
         "executionStats" : {
              "executionSuccess" : true,
              "nReturned" : 711,
              "executionTimeMillis" : 2,
              "totalKeysExamined" : 711,
              "totalDocsExamined" : 711,
              "executionStages" : {
                   "stage" : "PROJECTION_DEFAULT",
                   "nReturned" : 711,
                   "executionTimeMillisEstimate" : 0,
                   "works" : 712,
                   "advanced" : 711,
                   "needTime" : 0,
                   "needYield" : 0,
                   "saveState" : 5,
                   "restoreState" : 5,
                   "isEOF" : 1,
                   "transformBy" : {
                        "_id" : 0,
                        "customer.email" : 1,
                        "customer.age" : 1
                   },
                   "inputStage" : {
                        "stage" : "FETCH",
                        "nReturned" : 711,
                        "executionTimeMillisEstimate" : 0,
                        "works" : 712,
                        "advanced" : 711,
                        "needTime" : 0,
                        "needYield" : 0,
                        "saveState" : 5,
                        "restoreState" : 5,
                        "isEOF" : 1,
                        "docsExamined" : 711,
                        "alreadyHasObj" : 0,
                        "inputStage" : {
                             "stage" : "IXSCAN",
                             "nReturned" : 711,
                             "executionTimeMillisEstimate" : 0,
                             "works" : 712,
                             "advanced" : 711,
                             "needTime" : 0,
                             "needYield" : 0,
                             "saveState" : 5,
                             "restoreState" : 5,
                             "isEOF" : 1,
                             "keyPattern" : {
                                  "items.name" : 1,
                                  "storeLocation" : 1,
                                  "customer.age" : -1
                             },
                             "indexName" : "items.name_1_storeLocation_1_customer.age_-1",
                             "isMultiKey" : true,
                             "multiKeyPaths" : {
                                  "items.name" : [
                                       "items"
                                  ],
                                  "storeLocation" : [ ],
                                  "customer.age" : [ ]
                             },
                             "isUnique" : false,
                             "isSparse" : false,
                             "isPartial" : false,
                             "indexVersion" : 2,
                             "direction" : "forward",
                             "indexBounds" : {
                                  "items.name" : [
                                       "[\"backpack\", \"backpack\"]"
                                  ],
                                  "storeLocation" : [
                                       "[\"Denver\", \"Denver\"]"
                                  ],
                                  "customer.age" : [
                                       "[MaxKey, MinKey]"
                                  ]
                             },
                             "keysExamined" : 711,
                             "seeks" : 1,
                             "dupsTested" : 711,
                             "dupsDropped" : 0
                        }
                   }
              }
         }
    ```

    从输出可以明显看出，执行的第一阶段是**IXSCAN**，这意味着使用了正确的索引。还请注意，没有排序阶段。这意味着由于**customer.age**字段上的索引正确，因此不需要进一步排序。顶级执行统计数据显示，只扫描了**711**条记录，并且返回了相同数量的记录。这证明查询已正确优化。

在本活动中，您分析了查询的性能统计信息，确定了问题，并创建了正确的索引来解决性能问题。

# 10。复制

## 活动 10.01：测试 MongoDB 数据库的灾难恢复过程

**溶液：**

执行以下步骤以完成活动：

1.  Create the directories as follows: **C:\sale\sale-prod**, **C:\sale\sale-dr**, **C:\sale\sale-ab**, and **C:\sale\log**.

    笔记

    对于 Linux 和 macOS，目录名称类似于**/data/sales/sale prod**、**/data/sales/sale-dr.**

2.  按如下方式启动集群节点：

    ```
    start mongod --port 27001 --bind_ip_all --replSet sale-cluster --dbpath C:\sale\sale-prod --logpath C:\sale\log\sale-prod.log --logappend --oplogSize 50
    start mongod --port 27002 --bind_ip_all --replSet sale-cluster --dbpath C:\sale\sale-dr --logpath C:\sale\log\sale-dr.log --logappend --oplogSize 50
    start mongod --port 27003 --bind_ip_all --replSet sale-cluster --dbpath C:\sale\sale-ab --logpath C:\sale\log\sale-ab.log --logappend --oplogSize 50
    ```

3.  与 mongo 壳体连接：

    ```
     mongo mongodb://localhost:27001/?replicaSet=sale-cluster
    ```

4.  Create and activate the cluster configuration:

    ```
    var cfg = { 
        _id : "sale-cluster",
        members : [
            { _id : 0, host : "localhost:27001"},
            { _id : 1, host : "localhost:27002"},
            { _id : 2, host : "localhost:27003", arbiterOnly:true},
            ] 
    }
        rs.initiate(cfg)
    ```

    笔记

    集群选举成功后，您应该能够在 shell 提示符上看到**PRIMARY**。

5.  将**100**文档插入**样本**数据库。在主服务器上使用以下脚本创建**销售数据**集合并插入**100**文档：

    ```
    use sample_mflix
    db.createCollection("sales_data")
    for (i=0; i<=100; i++) {
        db.new_sales_data.insert({_id:i, "value":Math.random()})
    }
    ```

6.  通过添加以下命令关闭主服务器：

    ```
    use admin
    db.shutdownServer()
    ```

7.  Check that the primary is the DR instance by adding the following command (first disconnect and then connect again)

    ```
    rs.isMaster().primary
    ```

    结果应显示**销售额**。

8.  使用以下脚本在新的主实例上插入额外的 10 个文档（**sales_dr**）：

    ```
    use sample_mflix
    for (i=101; i<=110; i++) {
        db.new_sales_data.insert({_id:i, "value":Math.random()})
    }
    ```

9.  使用以下命令关闭 DR 数据库和仲裁器：

    ```
    use admin
    db.shutdownServer()
    ```

10.  确保两个主机都已关闭后，按如下方式重新启动前一个主主机：

    ```
    start mongod --port 27001 --bind_ip_all --replSet sale-cluster --dbpath C:\sale\sale-prod --logpath C:\sale\log\sale-prod.log --logappend --oplogSize 50
    ```

11.  Restart the arbiter as follows:

    ```
    start mongod --port 27003 --bind_ip_all --replSet sale-cluster --dbpath C:\sale\sale-ab --logpath C:\sale\log\sale-ab.log --logappend --oplogSize 50
    ```

    连接到群集。您应该无法看到插入到**sales\u dr**和**db 上的 10 个文档。新的【销售】数据。count（）**应该只重新运行 100。

12.  5 分钟后，按如下方式重新启动 DR 数据库：

    ```
    start mongod --port 27002 --bind_ip_all --replSet sale-cluster --dbpath C:\sale\sale-dr --logpath C:\sale\log\sale-dr.log --logappend --oplogSize 50
    ```

13.  重新启动后，验证**销售记录**文件中的步骤。在 DR 日志中，您应该可以看到如下消息：

    ```
    ROLLBACK [rsBackgroundSync] transition to SECONDARY
    2019-11-26T15:48:29.538+1000 I  REPL     [rsBackgroundSync] transition to SECONDARY from ROLLBACK
    2019-11-26T15:48:29.538+1000 I  REPL     [rsBackgroundSync] Rollback successful.
    ```

# 11。MongoDB 中的备份和恢复

## 活动 11.01：MongoDB 中的备份和恢复

**溶液：**

执行以下步骤以完成活动：

1.  从**mongoexport**开始。删除**--db**选项，因为您是在 URI 中提供它的。

    ```
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --collection=theaters --out="theaters.csv" --type=csv --sort='{theaterId: 1}'
    ```

2.  将字段选项添加到**mongoexport**命令

    ```
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --fields=theaterId,location --collection=theaters --out="theaters.csv" --type=csv --sort='{theaterId: 1}'
    ```

    中
3.  在导入命令中添加必要的 CSV 选项，即**类型**、**信号空白**和**标题线**。

    ```
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --type=CSV --headerline --ignoreBlanks --collection=theaters_import --file=theaters.csv 
    ```

4.  修复**转储**命令的**gzip**选项。

    ```
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=./backups –gzip --nsExclude=theaters
    ```

5.  将**N 排除**变更为**排除集合**：

    ```
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=./backups –gzip --excludeCollection=theaters
    ```

6.  在**mongorestore**命令中，修复选项名称：

    ```
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --nsFrom="sample_mflix" --nsTo="backup_mflix_backup" --drop ./backups
    ```

7.  同样在**mongorestore**中，添加**gzip**选项，因为您的转储文件是**gzip**：

    ```
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --nsFrom="sample_mflix" --nsTo="backup_mflix_backup" --gzip --drop ./backups
    ```

8.  最后，确保您的命名空间使用通配符进行专有名称迁移：

    ```
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --nsFrom="sample_mflix.*" --nsTo="backup_mflix_backup.*" --gzip --drop ./backups
    ```

9.  最后的**mongoexport**命令应该如下所示：

    ```
    mongoexport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --fields=theaterId,location --collection=theaters --out="theaters.csv" --type=csv --sort='{theaterId: 1}'
    ```

10.  最后的**mongoimport**命令应该如下所示：

    ```
    mongoimport --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/imports --type=CSV –headerline –ignoreBlanks --collection=theaters_import --file=theaters.csv 
    ```

11.  最后的**mongodump**命令应该如下所示：

    ```
    mongodump --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net/sample_mflix --out=./backups –gzip --excludeCollection=theaters
    ```

12.  The final **mongorestore** command should look as follows:

    ```
    mongorestore --uri=mongodb+srv://USERNAME:PASSWORD@myAtlas-fawxo.gcp.mongodb.net --nsFrom="sample_mflix.*" --nsTo="backup_mflix_backup.*" --gzip --drop ./backups
    ```

    笔记

    需要注意的是，由于**mongoimport**和**mongorestore**都将在数据库中创建新文档，因此必须使用具有写访问权限的凭据执行这些命令。

# 12。数据可视化

## 活动 12.01：创建销售演示文稿仪表板

**溶液：**

执行以下步骤以完成活动：

1.  Before you can start building the charts for this new presentation, you must define the appropriate data source in the application. Follow the steps from *Exercise 12.01*, *Working with Data Sources*, to create a new sales data source on the sales collection from the **sample_supplies** database, as shown in the following figure:

    ![Figure 12.52: Creating a new sales data source ](image/B15507_12_52.jpg)

    图 12.52：创建新的销售数据源

2.  Click **Finish** to save. The new data source will appear in the list as can be seen in the following figure:

    ![Figure 12.53: Sales Data Sources ](image/B15507_12_53.jpg)

    图 12.53：销售数据来源

3.  From the dashboard, click on the **ADD CHART** button as shown in the following screenshot:

    ![Figure 12.54: Clicking on ADD CHART in the User's Dashboard ](image/B15507_12_54.jpg)

    图 12.54：单击用户仪表板中的添加图表

    在**图表生成器**中，选择*步骤 2*中创建的销售数据源（即**样本【U supplies.sales】**，然后选择**循环**图表类型和**甜甜圈**图表子类型，如下图所示：

    ![Figure 12.55: Selecting the Circular chart type and the Donut chart sub-type ](image/B15507_12_55.jpg)

    图 12.55：选择圆形图表类型和圆环图子类型

4.  Unwind the **items** array. This step is important because the sales data is in an array format inside the JSON database. So, the **unwind** function will create a virtual document for each item in the array. To do so, add the following JSON code to the **Query** bar:

    ```
    [{$unwind:"$items"}]
    ```

    然后点击**应用**按钮，如下图所示：

    ![Figure 12.56: Writing the unwind function in the Query bar ](image/B15507_12_56.jpg)

    图 12.56：在查询栏中写入展开功能

5.  The next step is to add a new calculated field—that is, **items.value**. To do this, click on the **+ Add Field** button and add the new field as **items.value = items.price * items.quantity**, as can be seen in the following screenshot:

    ![Figure 12.57: Ading the items.value field ](image/B15507_12_57.jpg)

    图 12.57：读取 items.value 字段

6.  Add a filter so that only items from stores in **Denver** are considered for the chart. From the **Filter** tab, define the new filter for the store location by checking only the **Denver** location checkbox:

    ![Figure 12.58: Selecting only Denver from the list of locations ](image/B15507_12_58.jpg)

    图 12.58：仅从地点列表中选择丹佛

7.  Add channels in the **Encode** tab. As can be seen from the following figure, drag the field **items.name** into the **Label** channel. Select **VALUE** from the **SORT BY** dropdown and limit it to **10** results. That will split our donut into 10 slices. Similarly, drag **items.value** (the new calculated field) into the **Arc** channel, and choose the **SUM** function from the **AGGREGATE** dropdown:

    ![Figure 12.59: Dragging items.value into the Arc channel and choosing the SUM function ](image/B15507_12_59.jpg)

    图 12.59：将 items.value 拖动到 Arc 通道中并选择 SUM 函数

8.  The chart should appear on the right side of the screen as follows:

    ![Figure 12.60: Final chart ](image/B15507_12_60.jpg)

    图 12.60：最终图表

9.  Edit the chart name to **Denver Sales (million $)** as follows:

    ![Figure 12.61: Editing the chart title ](image/B15507_12_61.jpg)

    图 12.61：编辑图表标题

10.  Edit the chart labels. From the **Customize** tab, click to enable **Data Value Labels**, as follows:

    ![Figure 12.62: Customizing the data labels ](image/B15507_12_62.jpg)

    图 12.62：自定义数据标签

11.  Next, from the **Number Formatting** dropdown, choose **CUSTOM** with a maximum of **2** decimals, as follows:

    ![Figure 12.63: Customizing the chart formatting ](image/B15507_12_63.jpg)

    图 12.63：自定义图表格式

12.  The chart will appear with the right title and label formatting, as can be seen in the following figure:

    ![Figure 12.64: Final Denver Sales chart ](image/B15507_12_64.jpg)

图 12.64：丹佛最终销售图表

结果不言自明。正如预期的那样，笔记本电脑的销售额高达 200 万美元，是销售报告中迄今为止最有价值的项目。下一个销售项目是背包，价值只有 250000 美元。

活动现已完成。只需 10 个简单的步骤，您就可以为科罗拉多州丹佛市的商店中的商品创建顶级销售报告。您的图表构建现在已完成，可以将图表保存在仪表板上。学生和专业人士都可以利用这里学到的经验教训，利用真实数据进行演示。